<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Multiversity Algebra Chapter 0 Reading Group" />
  <title>Aluffi_AC0_Notes.en</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="/usr/share/javascript/mathjax/tex-mml-chtml.js" type="text/javascript"></script>
</head>
<body>
<p><code>row sep=normal, column sep=normal</code></p>
<h1 id="summaries">Summaries</h1>
<p>Chapter I)</p>
<p>Section 1) Explains fundamentals of set theory and basic set operations</p>
<p>Section 2) Explains set relations, set functions and some more advanced set operations</p>
<p>Section 3) Presents categories, and multiple examples of categories. Some are simple, some are advanced.</p>
<p>Section 4) Presents monomorphisms and epimorphisms in more detail, taking care to distinguish general morphisms from set functions and their accolytes (inj, surj, etc)</p>
<p>Section 5) Presents more advanced concepts from category theory, mostly some important universal properties</p>
<p>Chapter II)</p>
<h1 id="group-weekly-reports">Group Weekly Reports</h1>
<p>Week 1 : Today we mostly talked about the first chapter first section’s reading; going over the vocabulary term by term (see the lexicon on the github repo), and going more in depth over certain concepts (particularly relating to set relations). We also saw a bit of a "teaser" of how these notions are used. We did not go over the exercises since not everyone had done them.</p>
<p>Week 2 : Today we continued on discussing the first chapter, it was mostly freeform. We mostly talked about foundations of set theory (mostly stemming from the discussion of exercise 1 on russell’s paradox), why we use function notation the way we do, and about some of the operators over sets themselves (including through some examples from linear algebra and things like the subobject classifier which is seen at the end of section 3).</p>
<p>Week 3 : Today we finished discussing the first chapter. We went over all exercises. We mostly spoke about equivalence relations and partitions. We also spoke about the geometry/topology of quotients of sets by equivalence relations. This was naturally related to exercises 1.2 to 1.7.</p>
<p>Week 4 : We went over monomorphisms and epimorphisms in more depth. We corrected exercises 2.1 to 2.3 (included)</p>
<p>Week 5 : We went in depth over the distinction between isomorphisms and bijections (foreshadowing a bunch of category theory while we were at it) and corrected exercises 2.4 and 2.5.</p>
<p>Week 6 : We went in depth over the notion of section. We corrected exercises 2.6 and 2.7. For the latter exercise, we understood Tristan’s solution by ourselves ! (written by Amric)</p>
<p>Week 7 : We reviewed the notions of algebraic quotient and well-definition. We broached the notion of universal property. We used this to correct exercises 2.8 and 2.9.</p>
<p>Week 8 : We corrected exercises 2.10 and 2.11. We then did some preliminary explanations to present categories and help with the reading of section 3.</p>
<p>Week 9 : We spoke more in depth about category theory, concrete categories, local smallness, algebraic structures (and their vocabulary) and applied category theory.</p>
<p>Week 10 : We reviewed examples 3.2, 3.3, 3.4 and gave a bunch of disambiguation ideas for 3.5. Next week we’ll go over 3.5 and 3.6 in a bit more detail, and start correcting the exercises for this section. We’ll leave 3.7 and above for when we get to their respective exercises</p>
<h1 id="notes">Notes</h1>
<h2 class="unnumbered" id="chapter-1-section-1">Chapter 1, Section 1</h2>
<p>Go check out the extra exercises on set notation.</p>
<h2 class="unnumbered" id="chapter-1-section-2">Chapter 1, Section 2</h2>
<h3 class="unnumbered" id="on-injections-and-surjections">On injections and surjections</h3>
<h4 class="unnumbered" id="injections">Injections</h4>
<p>Injections (which aren’t also surjections) have multiple left-inverses (post-inverses). Eg:</p>
<p><span class="math display">\[A = \{ a, b    \}\]</span> <span class="math display">\[B = \{ 1, 2, 3 \}\]</span> <span class="math display">\[f : A \to B = \{ (a, 2), (b, 3) \} \text{, injective}\]</span></p>
<p><span class="math display">\[g_1 : B \to A = \{ (1, a), (2, a), (3, b) \}\]</span> <span class="math display">\[g_2 : B \to A = \{ (1, b), (2, a), (3, b) \}\]</span></p>
<p><span class="math display">\[g_1 \circ f = g_2 \circ f = id_A\]</span></p>
<p>It is precisely the free element with no antecedent in <span class="math inline">\(B\)</span> (here, <span class="math inline">\(1\)</span>) which leaves room for multiple choices, but doesn’t affect the overall inversion process.</p>
<h4 class="unnumbered" id="surjections">Surjections</h4>
<p>Surjections (which aren’t also injections) have multiple right-inverses (pre-inverses), called sections.</p>
<p><span class="math display">\[B = \{ 1, 2, 3 \}\]</span> <span class="math display">\[A = \{ a, b    \}\]</span> <span class="math display">\[f : B \to A = \{ (1, a), (2, a), (3, b) \} \text{, surjective}\]</span></p>
<p><span class="math display">\[g_1 : A \to B = \{(a, 1), (b, 3) \}\]</span> <span class="math display">\[g_2 : A \to B = \{(a, 2), (b, 3) \}\]</span></p>
<p><span class="math display">\[f \circ g_1 = f \circ g_2 = id_A\]</span></p>
<p>It is precisely the fact that there are multiple elements that map to the same element (here, <span class="math inline">\(1\)</span> and <span class="math inline">\(2\)</span> to <span class="math inline">\(a\)</span>) which leaves room for multiple choices, but doesn’t affect the overall inversion process.</p>
<h4 class="unnumbered" id="cancellations">Cancellations</h4>
<p>Function Cancellation Lemma: If a composition of functions cancels out, then the first of the pair is an injection, and the second of the pair is a surjection. Algebraically: <span class="math display">\[\forall A, B \in Obj(\textbf{Set}),
f \in (A \to B), g \in (B \to A), \;
    g \circ f = id_A
\Rightarrow
    \begin{cases}
        f \text{ is injective} \\
        g \text{ is surjective}
    \end{cases}\]</span></p>
<p>Corollary 1: any post-inverse of an injection is a surjection.</p>
<p>Corollary 2: any pre-inverse of a surjection is an injection.</p>
<p>Proof: Let be <span class="math display">\[A, B \in Obj(\textbf{Set}), f \in (A \to B), g \in (B \to A), \; g \circ f = id_A\]</span></p>
<p>a) Suppose <span class="math inline">\(f\)</span> is not an injection. This means: <span class="math display">\[\exists x, y \in B, \; x \neq y \text{ and } g(x) = g(y)\]</span> However, with such an <span class="math inline">\(f\)</span>, we have: <span class="math display">\[g(x) = g(y) \Rightarrow f(g(x)) = f(g(y)) = id_A(x) = id_A(y) = x = y\]</span> This means that <span class="math inline">\(f\)</span> is an injection. Contradiction.</p>
<p>Conclusion: in this context, <span class="math inline">\(f\)</span> must be an injection.</p>
<p>b) Suppose <span class="math inline">\(g\)</span> is not a surjection. This means: <span class="math display">\[\exists a \in A, \; a \notin g(B)\]</span> Since <span class="math inline">\(g \circ f = id_A\)</span>, that means that <span class="math inline">\(g(f(a)) = id_A(a) = a\)</span>, this means that <span class="math inline">\(a \in g(B)\)</span>. Contradiction.</p>
<p>Conclusion: in this context, <span class="math inline">\(g\)</span> must be a surjection.</p>
<h3 class="unnumbered" id="on-sections-and-fibers">On sections and fibers</h3>
<p>Section example with a tangent bundle.</p>
<p>Consider the cylinder <span class="math inline">\(S^1 \times \mathbb{R}\)</span>, and the function <span class="math inline">\(f : S^1 \times \mathbb{R} \to S^1\)</span>, the projection onto the circle. The cylinder is itself the space in which one can easily represent maps of <span class="math inline">\((S^1 \to \mathbb{R})\)</span>. Each such map corresponds to a section.</p>
<p>Let be</p>
<p><span class="math display">\[\begin{aligned}
g_1 : S^1    &amp; \longrightarrow  S^1 \times \mathbb{R} \\
      \theta &amp; \longmapsto      (\theta, 1)
\end{aligned}\]</span></p>
<p><span class="math display">\[\begin{aligned}
g_2 : S^1    &amp; \longrightarrow  S^1 \times \mathbb{R} \\
      \theta &amp; \longmapsto      (\theta, cos(\theta))
\end{aligned}\]</span></p>
<p>We have <span class="math display">\[f \circ g_1 = f \circ g_2 = id_{S^1}\]</span></p>
<p>(TODO add diagrams for S1xR, g1 and g2)</p>
<p>A fiber is the preimage of a singleton. In the case of <span class="math inline">\(f\)</span> above, for every <span class="math inline">\(q \in S^1\)</span>, <span class="math inline">\(f^{-1}({q})\)</span> is the copy of the real line on the cylinder that passes by <span class="math inline">\(q\)</span>.</p>
<p>(TODO add diagram)</p>
<h3 class="unnumbered" id="alternative-characterization-of-a-bijection">Alternative characterization of a bijection</h3>
<p>"<span class="math inline">\(f\)</span> is bijective" <span class="math inline">\(\Leftrightarrow\)</span> ("every element of <span class="math inline">\(B\)</span> has a non-empty fiber" (surjection) and "every fiber is a singleton" (injection))</p>
<h3 class="unnumbered" id="on-monomorphisms-and-epimorphisms">On monomorphisms and epimorphisms</h3>
<h4 class="unnumbered" id="failing-the-monoepi-condition">Failing the mono/epi condition</h4>
<h5 class="unnumbered" id="example-of-failing-the-monomorphism-definition-for-a-non-injection">Example of failing the monomorphism definition for a non-injection</h5>
<p>Monomorphism definition:</p>
<p><span class="math display">\[\text{$f : A \to B$ is a monomorphism}
\\ \Leftrightarrow \\
\forall Z \in \text{Obj}(\mathcal{C}), \;
\forall g_1, g_2 \in \text{Hom}(Z, A), \;
(f \circ g_1 = f \circ g_2 \Rightarrow g_1 = g_2)\]</span></p>
<p><span class="math display">\[A = \{ a, b, c \}\]</span> <span class="math display">\[B = \{ 1, 2    \}\]</span> <span class="math display">\[Z = \{ x, y    \}\]</span> <span class="math display">\[f : A \to B = \{ (a, 1), (b, 1), (c, 2) \} \text{, not injective}\]</span></p>
<p><span class="math display">\[g_1 : Z \to A = \{ (x, a), (y, c) \}\]</span> <span class="math display">\[g_2 : Z \to A = \{ (x, b), (y, c) \}\]</span></p>
<p><span class="math display">\[f \circ g_1 = f \circ g_2 = \{(x, 1), (y, 2)\} \in (Z \to B)\]</span></p>
<p>The multiple choice of elements (here, <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>) in <span class="math inline">\(A\)</span> which map to <span class="math inline">\(1\)</span> in <span class="math inline">\(B\)</span> is precisely what allows the overall composition to be equal, even when <span class="math inline">\(g_1 \neq g_2\)</span>. This provides insight into a proof of "<span class="math inline">\(f\)</span> is a monomorphism implies that <span class="math inline">\(f\)</span> is an injection". If you suppose that <span class="math inline">\(f\)</span> is a monomorphism and not an injection, you can easily reach a contradiction, since you can use elements like <span class="math inline">\(1\)</span> and <span class="math inline">\(2\)</span> that both map to the same <span class="math inline">\(a\)</span> to construct a counter-example to the implication that defines a monomorphism.</p>
<h5 class="unnumbered" id="example-of-failing-the-epimorphism-definition-for-a-non-surjection">Example of failing the epimorphism definition for a non-surjection</h5>
<p>Epimorphism definition:</p>
<p><span class="math display">\[\text{$f : A \to B$ is an epimorphism}
\\ \Leftrightarrow \\ 
\forall Z \in \text{Obj}(\mathcal{C}), \;
\forall g_1, g_2 \in \text{Hom}(B, Z), \;
(g_1 \circ f = g_2 \circ f \Rightarrow g_1 = g_2)\]</span></p>
<p><span class="math display">\[g_1 : Z \to A = \{ (x, a), (y, c) \}\]</span> <span class="math display">\[g_2 : Z \to A = \{ (x, b), (y, c) \}\]</span></p>
<p><span class="math display">\[f \circ g_1 = f \circ g_2 = \{(x, 1), (y, 2)\} \in (Z \to B)\]</span></p>
<p><span class="math display">\[A = \{ a, b    \}\]</span> <span class="math display">\[B = \{ 1, 2, 3 \}\]</span> <span class="math display">\[Z = \{ x, y    \}\]</span> <span class="math display">\[f : A \to B = \{ (a, 1), (b, 2) \} \text{, not surjective}\]</span></p>
<p><span class="math display">\[g_1 : B \to Z = \{ (1, x), (2, y), (3, x) \}\]</span> <span class="math display">\[g_2 : B \to Z = \{ (1, x), (2, y), (3, y) \}\]</span></p>
<p><span class="math display">\[g_1 \circ f = g_2 \circ f = \{(a, x), (b, y)\} \in (A \to Z)\]</span></p>
<p>The element <span class="math inline">\(3\)</span> in <span class="math inline">\(B\)</span> not being reached by <span class="math inline">\(f\)</span> is precisely that which provides the opportunity to build <span class="math inline">\(g_1 \neq g_2\)</span> such that they compose to the same result with <span class="math inline">\(f\)</span>, since the output of <span class="math inline">\(3\)</span> for them doesn’t affect the overall composition. This provides insight into a proof of "<span class="math inline">\(f\)</span> is an epimorphism implies that <span class="math inline">\(f\)</span> is a surjection". If you suppose that <span class="math inline">\(f\)</span> is an epimorphism and not a surjection, you can easily reach a contradiction, since you can use elements like <span class="math inline">\(3\)</span> that are not reached by <span class="math inline">\(f\)</span> to construct a counter-example to the implication that defines an epimorphism.</p>
<h4 class="unnumbered" id="proofs-of-monoinj-and-episurj-equivalence">Proofs of mono/inj and epi/surj equivalence</h4>
<p>Let <span class="math inline">\(f : A \to B\)</span>.</p>
<p>The parts which are "Injection =&gt; Monomorphism" and "Surjection =&gt; Epimorphism" both use the respective sided inverses to prove the implication.</p>
<p>The other parts use the following tautology to prove the implication by contradiction. "Suppose that <span class="math inline">\(p\)</span> and <span class="math inline">\(\neg q\)</span>, show that it leads to a contradiction".</p>
<p><span class="math display">\[(p \Rightarrow q)
\Leftrightarrow ((\neg  p) \cup      q )
\Leftrightarrow ( \neg (p  \cap \neg q))\]</span></p>
<h5 class="unnumbered" id="injection-monomorphism">Injection =&gt; Monomorphism</h5>
<p>Suppose that <span class="math inline">\(f\)</span> is an injection. It thus has post-inverses.</p>
<p><span class="math display">\[\exists g \in (B \to A), g \circ f = id_A\]</span></p>
<p>From there:</p>
<p><span class="math display">\[\forall Z \in \text{Obj}(\mathcal{C}), \;
\forall a, b \in \text{Hom}(Z, A),\]</span> <span class="math display">\[\begin{array}{ccccc} \\
f \circ a = f \circ b &amp; \Rightarrow &amp;  g \circ (f  \circ a) &amp;=&amp;  g \circ (f  \circ b) \\
                      &amp; =           &amp; (g \circ  f) \circ a  &amp;=&amp; (g \circ  f) \circ b  \\
                      &amp; =           &amp;         id_A \circ a  &amp;=&amp;         id_A \circ b  \\
                      &amp; =           &amp;                    a  &amp;=&amp;                    b
\end{array}\]</span></p>
<p>We conclude that <span class="math inline">\(f\)</span> is also a monomorphism.</p>
<h5 class="unnumbered" id="surjection-epimorphism">Surjection =&gt; Epimorphism</h5>
<p>Suppose that <span class="math inline">\(f\)</span> is a surjection. It thus has pre-inverses.</p>
<p><span class="math display">\[\exists g \in (B \to A), f \circ g = id_B\]</span></p>
<p>From there:</p>
<p><span class="math display">\[\forall Z \in \text{Obj}(\mathcal{C}), \;
\forall a, b \in \text{Hom}(B, Z),\]</span> <span class="math display">\[\begin{array}{ccccc} \\
a \circ f = b \circ f &amp; \Rightarrow &amp; (a \circ  f) \circ g  &amp;=&amp; (b \circ  f) \circ g  \\
                      &amp; =           &amp;  a \circ (f  \circ g) &amp;=&amp;  b \circ (f  \circ g) \\
                      &amp; =           &amp;  a \circ  id_B        &amp;=&amp;  b \circ  id_B        \\
                      &amp; =           &amp;  a                    &amp;=&amp;  b
\end{array}\]</span></p>
<p>We conclude that <span class="math inline">\(f\)</span> is also an epimorphism.</p>
<h5 class="unnumbered" id="monomorphism-injection">Monomorphism =&gt; Injection</h5>
<p>Suppose that <span class="math inline">\(f\)</span> is a monomorphism.</p>
<p><span class="math display">\[\forall Z \in \text{Obj}(\mathcal{C}), \;
\forall g_1, g_2 \in \text{Hom}(Z, A), \;
f \circ g_1 = f \circ g_2 \Rightarrow g_1 = g_2\]</span></p>
<p>Suppose now that <span class="math inline">\(f\)</span> is not an injection. Algebraically, this means that:</p>
<p><span class="math display">\[\exists (x, y) \in A^2, \text{ such that } x \neq y \text{ and } f(x) = f(y)\]</span></p>
<p>We can construct <span class="math inline">\(g_1\)</span> and <span class="math inline">\(g_2\)</span> such that <span class="math inline">\(f \circ g_1 = f \circ g_2\)</span> but <span class="math inline">\(g_1 \neq g_2\)</span>, using such a pair <span class="math inline">\((x, y)\)</span>. Thereby, we prove that <span class="math inline">\(f\)</span> is not an monomorphism and arrive at a contradiction.</p>
<p>(If <span class="math inline">\(Z\)</span> is the empty set, being initial in <span class="math inline">\(\mathbf{Set}\)</span>, there is only 1 map into <span class="math inline">\(A\)</span> (the empty map) and <span class="math inline">\(a = b\)</span> always hold. Therefore, any counterexample to the epimorphism definition needs to have at least 1 element.)</p>
<p>Let <span class="math inline">\(Z = \{a\}\)</span>.</p>
<p><span class="math display">\[g_1(a) = x\]</span> <span class="math display">\[g_2(a) = y\]</span></p>
<p>Clearly, <span class="math inline">\(g_1 \neq g_2\)</span>. However, we also have:</p>
<p><span class="math display">\[f(g_1(a)) = f(x) = f(y) = f(g_2(a)) \Rightarrow
f \circ g_1 = f \circ g_2\]</span></p>
<p>This means that <span class="math inline">\(f\)</span> is not a monomorphism: contradiction.</p>
<p>Conclusion: <span class="math inline">\(f\)</span> is an injection.</p>
<h5 class="unnumbered" id="epimorphism-surjection">Epimorphism =&gt; Surjection</h5>
<p>Suppose that <span class="math inline">\(f\)</span> is an epimorphism.</p>
<p><span class="math display">\[\forall Z \in \text{Obj}(\mathcal{C}), \;
\forall g_1, g_2 \in \text{Hom}(B, Z), \;
g_1 \circ f = g_2 \circ f \Rightarrow g_1 = g_2\]</span></p>
<p>Suppose now that <span class="math inline">\(f\)</span> isn’t a surjection. Algebraically, this means that:</p>
<p><span class="math display">\[\exists x \in B, x \notin f(A)\]</span></p>
<p>We can construct <span class="math inline">\(g_1\)</span> and <span class="math inline">\(g_2\)</span> such that <span class="math inline">\(g_1 \circ f = g_2 \circ f\)</span> but <span class="math inline">\(g_1 \neq g_2\)</span>, using such an <span class="math inline">\(x \notin f(A)\)</span>. Thereby, we prove that <span class="math inline">\(f\)</span> is not an epimorphism and arrive at a contradiction.</p>
<p>(If <span class="math inline">\(Z\)</span> is the singleton set, being terminal in <span class="math inline">\(\mathbf{Set}\)</span>, there is only 1 map into <span class="math inline">\(Z\)</span> and <span class="math inline">\(a = b\)</span> always hold. Therefore, any counterexample to the epimorphism definition needs to have at least 2 elements. We will however use a 3-element set, since it makes things more intuitive and pedagogical.)</p>
<p>Let <span class="math inline">\(Z = \{a, b, c\}\)</span>.</p>
<p><span class="math display">\[g_1 =
\begin{cases}
    \forall x    \in f(A), g_1(x) = a \\
    \forall x \notin f(A), g_1(x) = b
\end{cases}\]</span></p>
<p><span class="math display">\[g_2 =
\begin{cases}
    \forall x    \in f(A), g_2(x) = a \\
    \forall x \notin f(A), g_2(x) = c
\end{cases}\]</span></p>
<p>Clearly, <span class="math inline">\(g_1 \neq g_2\)</span>. However, since <span class="math inline">\(A\)</span> is the domain of <span class="math inline">\(f\)</span>, of <span class="math inline">\(g_1 \circ f\)</span>, and of <span class="math inline">\(g_2 \circ f\)</span>, we have:</p>
<p><span class="math display">\[g_1 \circ f = g_2 \circ f = (x \mapsto a) \in (A \to Z)\]</span></p>
<p>This means that <span class="math inline">\(f\)</span> is not an epimorphism: contradiction.</p>
<p>Conclusion: <span class="math inline">\(f\)</span> is a surjection.</p>
<h2 class="unnumbered" id="chapter-1-section-3">Chapter 1, Section 3</h2>
<h3 class="unnumbered" id="example-summary">Example summary</h3>
<ul>
<li><p>(3.2): Set, category of sets as objects and set functions as morphisms.</p></li>
<li><p>(3.3): preorder (or order, or equivalence relation) over a (single) set, transformed into a category; elements of the set as objects, and elements of the preorder (which is a relation, hence a subset of the cartesian product) as morphisms.</p></li>
<li><p>(3.4): the powerset with the inclusion operator, transformed into a category; elements of the powerset (i.e., subsets of the set) as objects, and inclusion relations as morphisms (this is just an example of a preorder / order / equivalence category seen in 3.3).</p></li>
<li><p>(3.5): slice categories <span class="math inline">\(\mathcal{C}_A\)</span>, categories which isolate a specific object <span class="math inline">\(A\)</span> of a given category <span class="math inline">\(\mathcal{C}\)</span>, and studies the morphisms into that object; an object of <span class="math inline">\(\mathcal{C}_A\)</span> is any morphism from any arbitrary objet <span class="math inline">\(Z\)</span> into <span class="math inline">\(A\)</span> (not the homset <span class="math inline">\(Hom(Z, A)\)</span> itself !) and a morphism in <span class="math inline">\(\mathcal{C}_A\)</span> (from <span class="math inline">\(z_1 \in Z_1 \to A\)</span> to <span class="math inline">\(z_2 \in Z_2 \to A\)</span>) is a "raising" <span class="math inline">\(\sigma_A\)</span> into <span class="math inline">\(\mathcal{C}_A\)</span> of a morphism <span class="math inline">\(\sigma \in Z_1 \to Z_2\)</span> in <span class="math inline">\(\mathcal{C}\)</span> that preserves composition on morphisms in <span class="math inline">\(\mathcal{C}\)</span> (i.e., <span class="math inline">\(z_1 = z_2 \sigma \Rightarrow \sigma_A z_1 = z_2\)</span>).</p></li>
<li><p>(3.6): combining examples 3.3 and 3.5, first start with an order category on the set <span class="math inline">\(\mathbb{Z}\)</span> (there is a morphism <span class="math inline">\(m \to n\)</span> iff <span class="math inline">\(m \leq n\)</span>), then select a specific object (here, <span class="math inline">\(A = 3\)</span>) then study all morphisms of the category into <span class="math inline">\(A\)</span> (so the relation <span class="math inline">\(n \leq 3\)</span> for any <span class="math inline">\(Z = n\)</span>); the morphisms <span class="math inline">\(\sigma_3 = (m, 3) \to (n, 3)\)</span> are then simply given by the transitivity of <span class="math inline">\(\leq\)</span>, i.e., <span class="math inline">\(m \leq n \leq 3\)</span> (<span class="math inline">\((m, 3) \to (n, 3)\)</span> corresponds to <span class="math inline">\(m \leq 3 \Rightarrow n \leq 3\)</span>, meaning our <span class="math inline">\(z_1 = z_2 \sigma\)</span> transforming into <span class="math inline">\(\sigma_A z_1 = z_2\)</span>, here, corresponds to <span class="math inline">\((m \leq 3) = (n \leq 3) \cap (m \leq n)\)</span> is transformed into <span class="math inline">\((m \leq 3 \Rightarrow n \leq 3) \cap (m \leq 3) \Leftrightarrow (n \leq 3)\)</span>).</p></li>
<li><p>(3.7): coslice categories (morphisms out of a chosen object).</p></li>
<li><p>(3.8): the category <strong>Set<span class="math inline">\(^\star\)</span></strong> of pointed sets, a coslice category over <strong>Set</strong> and any singleton set <span class="math inline">\(\{ \star \}\)</span>. Objects in <strong>Set<span class="math inline">\(^\star\)</span></strong> are regular sets, but with a unique distinguished element; morphisms are any set functions that map the domain’s distinguised element to the codomain’s distinguished element.</p></li>
<li><p>(3.9): "bislice" and "bicoslice" categories, basically a similar construct as slice and coslice, but taking two objects of the starting category, and studying pairs of morphisms (from a common domain, resp codomain) into (resp from) this pair.</p></li>
<li><p>(3.10): "fibered bislice" and "fibered bicoslice" categories, once again a similair construct, but this time taking two <em>morphisms</em> into a common set C (resp. from a common set C).</p></li>
</ul>
<h3 class="unnumbered" id="on-terminal-and-initial-objects-in-set">On terminal and initial objects in <strong>Set</strong></h3>
<p>If <span class="math inline">\(\empty\)</span> is initial and <span class="math inline">\(\{ \star \}\)</span> is terminal, it is because a function in <span class="math inline">\(Set\)</span> (in categorical terms) must always have an output for every input. Ie, in category theory, all functions are maps ("applications").</p>
<p>Said algebraically:</p>
<p><span class="math display">\[\forall A, B \in \text{Obj}(\bold{Set}), \;
\forall a \in A, \;
\forall f \in \text{Hom}(A, B), \;
\exists f(a) \in B\]</span></p>
<p>In the case of <span class="math inline">\(\empty\)</span> as the input set, and there is only one function <span class="math inline">\(f: \empty \to Z\)</span> for any <span class="math inline">\(Z\)</span>: <span class="math inline">\(f\)</span> is the empty mapping. But any <span class="math inline">\(Z \to \empty\)</span> (expept <span class="math inline">\(\empty \to \empty\)</span>) contains no mapping (since we’d necessarily be ignoring at least one element of <span class="math inline">\(Z\)</span>).</p>
<p>Similarly, in the case of the (unique up-to-isomorphism) singleton set <span class="math inline">\(\{ \star \}\)</span> as the output, you’d have multiple functions (precisely <span class="math inline">\(2^{|Z|}\)</span>) into it, if you could ignore some elements of the input set. However, if all elements of the input set are required, that leaves you with only one function possible from <span class="math inline">\(Z \to \{ \star \}\)</span>: the function which maps all elements to <span class="math inline">\(\star\)</span>.</p>
<h3 class="unnumbered" id="restrictions-and-extensions-of-functions-and-its-consequences-on-a-functions-nature">Restrictions and extensions of functions, and its consequences on a function’s nature</h3>
<p>8 possibilities to study, based on the following binary dichotomies:</p>
<ul>
<li><p>injection or surjection</p></li>
<li><p>enlarging or restricting</p></li>
<li><p>domain or codomain</p></li>
</ul>
<p>Note that enlarging the domain sometimes implies enlarging the codomain, and restricting the codomain sometimes implies restricting the domain.</p>
<p>Legend: Yes, No, Depends</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">enlarge dom</td>
<td style="text-align: center;">restrict dom</td>
<td style="text-align: center;">enlarge cod</td>
<td style="text-align: center;">restrict cod</td>
</tr>
<tr class="even">
<td style="text-align: center;">injection</td>
<td style="text-align: center;">D</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">Y</td>
</tr>
<tr class="odd">
<td style="text-align: center;">surjection</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">D</td>
<td style="text-align: center;">N</td>
<td style="text-align: center;">Y</td>
</tr>
</tbody>
</table>
<p>Theorems:</p>
<p>A) if <span class="math inline">\(f \in (A \to B), f \text{ injective (resp. surjective)}\)</span>, then <span class="math inline">\(\forall Z \subseteq B, \hat{f} \in ((f^{-1}(Z) \subseteq A) \to Z), \hat{f} = f|_{f^{-1}(Z)}\)</span>, the restriction of the function to the corresponding smaller codomain, is also an injection (resp. surjection).</p>
<p>B) if <span class="math inline">\(f \in (A \to B), f \text{ injective (resp. surjective)}\)</span>, then <span class="math inline">\(\forall Z \supseteq B, \hat{f} \in (A \to Z), \hat{f} = \iota \circ f\)</span> (with the <span class="math inline">\(\iota\)</span> the canonical injection of <span class="math inline">\(b \in B\)</span> into its superset <span class="math inline">\(Z\)</span>), is also an injection (resp. is never a surjection).</p>
<p>C) if <span class="math inline">\(f \in (A \to B), f \text{ injective}\)</span>, then <span class="math inline">\(\forall Z \subseteq A, \hat{f} \in (Z \to B), f = \iota_{(Z \to A)} \circ \hat{f}\)</span>, we have that <span class="math inline">\(\hat{f}\)</span> is also an injection. However, one can construct <span class="math inline">\(Z \subseteq A\)</span> such that <span class="math inline">\(f\)</span> stops being a surjection.</p>
<p>D) if <span class="math inline">\(f \in (A \to B), f \text{ surjective}\)</span>, then <span class="math inline">\(\forall Z \supseteq A, \hat{f} \in (Z \to (B \cup f(Z))), f = \iota_{(Z \to A)} \circ \hat{f}\)</span>, we have that <span class="math inline">\(\hat{f}\)</span> is also a surjection. However, one can construct <span class="math inline">\(Z \subseteq A\)</span> such that <span class="math inline">\(f\)</span> stops being a injection.</p>
<p>Proof: TODO</p>
<h3 class="unnumbered" id="on-the-morphisms-of-slice-and-coslice-categories">On the morphisms of slice and coslice categories</h3>
<p>Given a base category <span class="math inline">\(\mathcal{C}\)</span>, and some set <span class="math inline">\(A\)</span> we wish to study the homsets of the slice (resp. coslice) category <span class="math inline">\(\mathcal{C}_A\)</span> (resp. <span class="math inline">\(\mathcal{C}^A\)</span>. <strong>These homsets might be empty, or have more than one element.</strong></p>
<p>We remind that slice categories consider <em>morphisms to A</em> as their <em>objects</em> (written as <span class="math inline">\((Z, \varphi)\)</span> for any <span class="math inline">\(\varphi : Z \to A\)</span>), while coslice categories consider <em>morphisms from A</em> as their <em>objects</em> (written as <span class="math inline">\((\varphi, Z)\)</span> for any <span class="math inline">\(\varphi : A \to Z\)</span>. <em>Morphisms</em>, of the form <span class="math inline">\(\sigma_A : (Z_1, \varphi_1) \to (Z_2, \varphi_2)\)</span> (resp. <span class="math inline">\(\sigma^A : (\varphi_1, Z_1) \to (\varphi_2, Z_2)\)</span>) in a slice category <span class="math inline">\(\mathcal{C}_A\)</span> (resp. coslice category <span class="math inline">\(\mathcal{C}^A\)</span>) map such objects to one another if and only if there exists a morphism in <span class="math inline">\(\mathcal{C}\)</span> (the base category!) such that <span class="math inline">\(\varphi_1 = \varphi_2 \sigma\)</span> (resp. <span class="math inline">\(\sigma \varphi_1 = \varphi_2\)</span>).</p>
<h4 class="unnumbered" id="example-of-no-sigma-for-a-slice-category">Example of no <span class="math inline">\(\sigma\)</span> for a slice category</h4>
<p>For example, note that there exist pairs of morphisms <span class="math inline">\(f_1 \in (Z_1 \to A)\)</span> and <span class="math inline">\(f_2 \in (Z_2 \to A)\)</span> between which there is no morphism that exists in the slice category. One such example we can make is in <span class="math inline">\((Vect_\mathbb{R})_{\mathbb{R}^2}\)</span>. If we take the maps:</p>
<p><span class="math display">\[f_1 = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 0 \end{bmatrix} \in \mathcal{L}(\mathbb{R}^2)\]</span> <span class="math display">\[f_2 = \begin{bmatrix} 0 &amp; 0 \\ 0 &amp; 1 \end{bmatrix} \in \mathcal{L}(\mathbb{R}^2)\]</span></p>
<p>There exists no map <span class="math inline">\(\sigma\)</span> such that the following diagram commutes (since the output of <span class="math inline">\(f_1\)</span> will always be null in its second coordinate, and the output of <span class="math inline">\(f_2\)</span> will always be null in the first):</p>
<h4 class="unnumbered" id="example-of-no-sigma-for-a-coslice-category">Example of no <span class="math inline">\(\sigma\)</span> for a coslice category</h4>
<p>TODO add potato diagram</p>
<p>Take <span class="math inline">\(A = Z_2 = \{ a, b, c \}\)</span>, <span class="math inline">\(\varphi_2 = id_A\)</span>, and <span class="math inline">\(Z_1 = \{ 1, 2 \}\)</span>. Since <span class="math inline">\(|Z_1| = |dom(\sigma)| &lt; |cod(\sigma)| = |Z_2|\)</span>, there is no possible case in which <span class="math inline">\(\text{Im} (\sigma) = \text{Im} (id_A)\)</span> (even if <span class="math inline">\(\varphi_1\)</span> is epi).</p>
<h4 class="unnumbered" id="example-of-multiple-sigma">Example of multiple <span class="math inline">\(\sigma\)</span></h4>
<p>TODO add potato diagram</p>
<p>Another example, this time in a coslice category, with <span class="math inline">\(A = \{ a, b, c \}\)</span>, we take <span class="math inline">\(\text{\textbf{Set}}_A\)</span>. We take <span class="math inline">\(Z_1 = \{ 1, 2, 3 \}\)</span>, <span class="math inline">\(Z_2 = \{T, F\}\)</span>. For <span class="math inline">\(\varphi_1 : A \to Z_1 = \{(a, 1), (b, 1), (c, 3)\}\)</span> and <span class="math inline">\(\varphi_2 : A \to Z_2 = \{(a, T), (b, T), (c, F)\}\)</span> there exists two elements in <span class="math inline">\(Hom_{\mathcal{Set}^A} (Z_1, Z_2)\)</span>. These originate from two functions in <strong>Set</strong>: <span class="math inline">\(\sigma_\alpha = \{ (1, T), (2, T), (3, F) \}\)</span> and <span class="math inline">\(\sigma_\beta = \{ (1, T), (2, F), (3, F) \}\)</span>. The free element in <span class="math inline">\(2 \in Z_1\)</span> which is not in <span class="math inline">\(\text{Im} (\varphi_1)\)</span> offers a degree of freedom.</p>
<h4 class="unnumbered" id="explanations-on-the-conditions-for-sigma">Explanations on the conditions for <span class="math inline">\(\sigma\)</span></h4>
<p>In the first example, what causes the issue is the fact that the images of <span class="math inline">\(f_1\)</span> and <span class="math inline">\(f_2\)</span> in <span class="math inline">\(A\)</span> are distinct.</p>
<p>In the second example, what causes the issue is the fact that we’ve reduced our common domain <span class="math inline">\(A\)</span> to an insufficient intermediary object <span class="math inline">\(Z_1\)</span>.</p>
<p>The "element which isn’t mapped to offers a degree of freedom and thus breaks unicity" in the last example should remind you of the notes on surjections. Indeed, when comparing <span class="math inline">\(\sigma_\alpha\)</span> and <span class="math inline">\(\sigma_\beta\)</span>, we’re in a context which is reminiscent of the definition of an epimorphism.</p>
<p><span class="math display">\[\varphi_2 = \sigma_\alpha \varphi_1 = \sigma_\alpha \varphi_1\]</span></p>
<p>We can be assured of being able to cancel <span class="math inline">\(\varphi 1\)</span> iff <span class="math inline">\(\varphi_1\)</span> is an epimorphism, and thus <span class="math inline">\(\sigma\)</span>, if it exists, is unique. The proof for slice categories is similar, but given the reverse orders, uses monomorphisms.</p>
<p>More generally:</p>
<ul>
<li><p>a) in a slice category, there will be no <span class="math inline">\(\sigma\)</span> if <span class="math inline">\(\text{Im} (\varphi_1) \neq \text{Im} (\varphi_2)\)</span> (proof ? and in more general categories than concrete categories ? TODO: iff ?)</p></li>
<li><p>b) in a coslice category, there will be no <span class="math inline">\(\sigma\)</span> if <span class="math inline">\(\text{Pr} (\text{Im} (\varphi_1) \neq \text{Pr} (\text{Im} (\varphi_2))\)</span> (proof ? and in more general categories than concrete categories ? TODO: iff ?)</p></li>
<li><p>c) in a slice category, there is at most a single <span class="math inline">\(\sigma\)</span> iff <span class="math inline">\(\varphi_2\)</span> is mono</p></li>
<li><p>d) in a coslice category, there is at most a single <span class="math inline">\(\sigma\)</span> iff <span class="math inline">\(\varphi_1\)</span> is epi</p></li>
</ul>
<p>(see perhaps https://ncatlab.org/nlab/show/over+category and https://ncatlab.org/nlab/show/under+category )</p>
<h2 class="unnumbered" id="chapter-1-section-4">Chapter 1, Section 4</h2>
<h3 class="unnumbered" id="notes-on-counterintuitive-rules">Notes on counterintuitive rules</h3>
<ul>
<li><p>in some categories (such as <span class="math inline">\(\mathbb{Z}\)</span> with <span class="math inline">\(\leq\)</span>; or <strong>Ring</strong>), "mono and epi" does not imply "iso"</p></li>
<li><p>in every <em>abelian</em> category, we have that "iso <span class="math inline">\(\Leftrightarrow\)</span> epi and mono" (and though <strong>Set</strong> is not abelian, the property still holds)</p></li>
<li><p>while in <strong>Set</strong>, a function is an epimorphism (surjective) iff it has a pre-inverse, in <strong>Grp</strong>, some epimorphisms do not have right inverses.</p></li>
</ul>
<h2 class="unnumbered" id="chapter-1-section-5">Chapter 1, Section 5</h2>
<h3 class="unnumbered" id="initial-and-terminal-objects">Initial and terminal objects</h3>
<ul>
<li><p>there are categories without either initial or terminal objects, such as the preorder category of <span class="math inline">\(\mathbb{Z}\)</span> with <span class="math inline">\(\leq\)</span>.</p></li>
<li><p>there are categories with multiple initial or terminal objects (for example, in <strong>Set</strong>, every singleton set is a terminal object); however, these are respectively unique up to isomorphism</p></li>
<li><p>any object which is both initial and terminal is called a zero object.</p></li>
</ul>
<h3 class="unnumbered" id="universal-properties">Universal properties</h3>
<h4 class="unnumbered" id="normal-universal-properties">"Normal" universal properties</h4>
<p>Verbatim: "The most natural context in which to introduce universal properties requires a good familiarity with the language of functors, which we will only introduce at a later stage. [...] We say that a construction satisﬁes a universal property (or: ’is the solution to a universal problem’) when it may be viewed as a terminal object of a category."</p>
<p>Then: "The declaration/explanation of a universal property generally follows the pattern ’object X is universal with respect to the following property: for any Y such that..., there exists a unique morphism Y → X such that...’; this explanation hides the deﬁnition of an accessory category, and the statement that X is terminal."</p>
<p>This is a complicated way to say: there is some construct to decompose a morphism which is "universal" (always exists) and reduces the rest of the information of the morphism into something "unique" (hence terminal object of some subcategory).</p>
<h4 class="unnumbered" id="dual-universal-properties">Dual universal properties</h4>
<h1 id="lexicon">Lexicon</h1>
<h2 class="unnumbered" id="chapter-1">Chapter 1</h2>
<h3 class="unnumbered" id="section-1">Section 1</h3>
<ul>
<li><p>Set (not a multiset)</p></li>
<li><p><span class="math inline">\(\emptyset\)</span>: the empty set, containing no elements;</p></li>
<li><p><span class="math inline">\(\mathbb{N}\)</span>: the set of natural numbers (that is, nonnegative integers);</p></li>
<li><p><span class="math inline">\(\mathbb{Z}\)</span>: the set of integers;</p></li>
<li><p><span class="math inline">\(\mathbb{Q}\)</span>: the set of rational numbers;</p></li>
<li><p><span class="math inline">\(\mathbb{R}\)</span>: the set of real numbers;</p></li>
<li><p><span class="math inline">\(\mathbb{C}\)</span>: the set of complex numbers.</p></li>
<li><p>Singleton:</p></li>
<li><p><span class="math inline">\(\exists\)</span>: existential quantifier, "there exists"</p></li>
<li><p><span class="math inline">\(\forall\)</span>: universal quantifier, "for all"</p></li>
<li><p>inclusion:</p></li>
<li><p>subset:</p></li>
<li><p>cardinal:</p></li>
<li><p>powerset:</p></li>
<li><p><span class="math inline">\(\cup\)</span>: the union:</p></li>
<li><p><span class="math inline">\(\cap\)</span>: the intersection:</p></li>
<li><p><span class="math inline">\(\\\)</span>: the difference:</p></li>
<li><p><span class="math inline">\(\coprod\)</span>: the disjoint union:</p></li>
<li><p><span class="math inline">\(\times\)</span>: the (Cartesian) product:</p></li>
<li><p>complement of a subset</p></li>
<li><p>relation</p></li>
<li><p>order relation</p></li>
<li><p>equivalence relation</p></li>
<li><p>reflexivity</p></li>
<li><p>symmetry</p></li>
<li><p>antisymmetry</p></li>
<li><p>transitivity</p></li>
<li><p>partition</p></li>
<li><p><span class="math inline">\(/\sim\)</span>: quotient by an equivalence relation</p></li>
</ul>
<h3 class="unnumbered" id="section-2">Section 2</h3>
<ul>
<li><p>function</p></li>
<li><p>graph</p></li>
<li><p>(categorical, function) diagram</p></li>
<li><p>identity function</p></li>
<li><p>kernel (of a function)</p></li>
<li><p>image (of a function)</p></li>
<li><p>restriction (of a function to a subset)</p></li>
<li><p>multiset</p></li>
<li><p>composition</p></li>
<li><p>commutative (diagram)</p></li>
<li><p>injection</p></li>
<li><p>surjection</p></li>
<li><p>bijection</p></li>
<li><p>isomorphism</p></li>
<li><p>inverse</p></li>
<li><p>pre-inverse, right-inverse</p></li>
<li><p>post-inverse, left-inverse</p></li>
<li><p>monomorphism</p></li>
<li><p>epimorphism</p></li>
<li><p>natural projection</p></li>
<li><p>natural injection</p></li>
<li><p>canonical decomposition (of a function)</p></li>
</ul>
<h3 class="unnumbered" id="section-3">Section 3</h3>
<ul>
<li><p>category</p></li>
<li><p>object</p></li>
<li><p>morphism</p></li>
<li><p>endomorphism</p></li>
<li><p>operation</p></li>
<li><p>discrete category</p></li>
<li><p>small category</p></li>
<li><p>locally small category</p></li>
<li><p>slice category</p></li>
<li><p>coslice category</p></li>
<li><p>comma category (mentioned, undefined)</p></li>
<li><p>pointed set</p></li>
<li><p><span class="math inline">\(C^{A, B}\)</span> category ?? (bislice, bicoslice, fibered bislice, fibered bicoslice)</p></li>
<li><p>dual category</p></li>
</ul>
<h3 class="unnumbered" id="section-4">Section 4</h3>
<ul>
<li><p>automorphism</p></li>
</ul>
<h3 class="unnumbered" id="section-5">Section 5</h3>
<ul>
<li><p>universal property</p></li>
<li><p>initial object</p></li>
<li><p>final object</p></li>
<li><p>terminal object</p></li>
<li><p>(categorical) product</p></li>
<li><p>(categorical) coproduct</p></li>
<li><p>(categorical) pullback / fibered product</p></li>
<li><p>(categorical) pushout / fibered coproduct</p></li>
<li><p>(set) pullback / fibered product</p></li>
<li><p>(set) pushout / fibered coproduct</p></li>
</ul>
</body>
</html>
