Multiversity Algebra Chapter 0 Reading Group

row sep=normal, column sep=normal

Summaries

Chapter I)

Section 1) Explains fundamentals of set theory and basic set operations

Section 2) Explains set relations, set functions and some more advanced
set operations

Section 3) Presents categories, and multiple examples of categories.
Some are simple, some are advanced.

Section 4) Presents monomorphisms and epimorphisms in more detail,
taking care to distinguish general morphisms from set functions and
their accolytes (inj, surj, etc)

Section 5) Presents more advanced concepts from category theory, mostly
some important universal properties

Chapter II)

Group Weekly Reports

Week 1 : Today we mostly talked about the first chapter first sectionâ€™s
reading; going over the vocabulary term by term (see the lexicon on the
github repo), and going more in depth over certain concepts
(particularly relating to set relations). We also saw a bit of a
"teaser" of how these notions are used. We did not go over the exercises
since not everyone had done them.

Week 2 : Today we continued on discussing the first chapter, it was
mostly freeform. We mostly talked about foundations of set theory
(mostly stemming from the discussion of exercise 1 on russellâ€™s
paradox), why we use function notation the way we do, and about some of
the operators over sets themselves (including through some examples from
linear algebra and things like the subobject classifier which is seen at
the end of section 3).

Week 3 : Today we finished discussing the first chapter. We went over
all exercises. We mostly spoke about equivalence relations and
partitions. We also spoke about the geometry/topology of quotients of
sets by equivalence relations. This was naturally related to exercises
1.2 to 1.7.

Week 4 : We went over monomorphisms and epimorphisms in more depth. We
corrected exercises 2.1 to 2.3 (included)

Week 5 : We went in depth over the distinction between isomorphisms and
bijections (foreshadowing a bunch of category theory while we were at
it) and corrected exercises 2.4 and 2.5.

Week 6 : We went in depth over the notion of section. We corrected
exercises 2.6 and 2.7. For the latter exercise, we understood Tristanâ€™s
solution by ourselves ! (written by Amric)

Week 7 : We reviewed the notions of algebraic quotient and
well-definition. We broached the notion of universal property. We used
this to correct exercises 2.8 and 2.9.

Week 8 : We corrected exercises 2.10 and 2.11. We then did some
preliminary explanations to present categories and help with the reading
of section 3.

Week 9 : We spoke more in depth about category theory, concrete
categories, local smallness, algebraic structures (and their vocabulary)
and applied category theory.

Week 10 : We reviewed examples 3.2, 3.3, 3.4 and gave a bunch of
disambiguation ideas for 3.5. Next week weâ€™ll go over 3.5 and 3.6 in a
bit more detail, and start correcting the exercises for this section.
Weâ€™ll leave 3.7 and above for when we get to their respective exercises

Notes

Chapter 1, Section 1

Go check out the extra exercises on set notation.

Chapter 1, Section 2

On injections and surjections

Injections

Injections (which arenâ€™t also surjections) have multiple left-inverses
(post-inverses). Eg:

Aâ€„=â€„{a,â€†b}
Bâ€„=â€„{1,â€†2,â€†3}
fâ€„:â€„Aâ€„â†’â€„Bâ€„=â€„{(a,â€†2),â€†(b,â€†3)}, injective

gâ‚â€„:â€„Bâ€„â†’â€„Aâ€„=â€„{(1,â€†a),â€†(2,â€†a),â€†(3,â€†b)}
gâ‚‚â€„:â€„Bâ€„â†’â€„Aâ€„=â€„{(1,â€†b),â€†(2,â€†a),â€†(3,â€†b)}

gâ‚â€…âˆ˜â€…fâ€„=â€„gâ‚‚â€…âˆ˜â€…fâ€„=â€„id_(A)

It is precisely the free element with no antecedent in B (here, 1) which
leaves room for multiple choices, but doesnâ€™t affect the overall
inversion process.

Surjections

Surjections (which arenâ€™t also injections) have multiple right-inverses
(pre-inverses), called sections.

Bâ€„=â€„{1,â€†2,â€†3}
Aâ€„=â€„{a,â€†b}
fâ€„:â€„Bâ€„â†’â€„Aâ€„=â€„{(1,â€†a),â€†(2,â€†a),â€†(3,â€†b)}, surjective

gâ‚â€„:â€„Aâ€„â†’â€„Bâ€„=â€„{(a,â€†1),â€†(b,â€†3)}
gâ‚‚â€„:â€„Aâ€„â†’â€„Bâ€„=â€„{(a,â€†2),â€†(b,â€†3)}

fâ€…âˆ˜â€…gâ‚â€„=â€„fâ€…âˆ˜â€…gâ‚‚â€„=â€„id_(A)

It is precisely the fact that there are multiple elements that map to
the same element (here, 1 and 2 to a) which leaves room for multiple
choices, but doesnâ€™t affect the overall inversion process.

Cancellations

Function Cancellation Lemma: If a composition of functions cancels out,
then the first of the pair is an injection, and the second of the pair
is a surjection. Algebraically:
$$\forall A, B \in Obj(\textbf{Set}),
f \in (A \to B), g \in (B \to A), \;
    g \circ f = id_A
\Rightarrow
    \begin{cases}
        f \text{ is injective} \\
        g \text{ is surjective}
    \end{cases}$$

Corollary 1: any post-inverse of an injection is a surjection.

Corollary 2: any pre-inverse of a surjection is an injection.

Proof: Let be
A,â€†Bâ€„âˆˆâ€„Obj(Set),â€†fâ€„âˆˆâ€„(Aâ€„â†’â€„B),â€†gâ€„âˆˆâ€„(Bâ€„â†’â€„A),â€…gâ€…âˆ˜â€…fâ€„=â€„id_(A)

a) Suppose f is not an injection. This means:
âˆƒx,â€†yâ€„âˆˆâ€„B,â€…xâ€„â‰ â€„y and g(x)â€„=â€„g(y)
However, with such an f, we have:
g(x)â€„=â€„g(y)â€„â‡’â€„f(g(x))â€„=â€„f(g(y))â€„=â€„id_(A)(x)â€„=â€„id_(A)(y)â€„=â€„xâ€„=â€„y
This means that f is an injection. Contradiction.

Conclusion: in this context, f must be an injection.

b) Suppose g is not a surjection. This means:
âˆƒaâ€„âˆˆâ€„A,â€…aâ€„âˆ‰â€„g(B)
Since gâ€…âˆ˜â€…fâ€„=â€„id_(A), that means that g(f(a))â€„=â€„id_(A)(a)â€„=â€„a, this
means that aâ€„âˆˆâ€„g(B). Contradiction.

Conclusion: in this context, g must be a surjection.

On sections and fibers

Section example with a tangent bundle.

Consider the cylinder SÂ¹â€…Ã—â€…â„, and the function fâ€„:â€„SÂ¹â€…Ã—â€…â„â€„â†’â€„SÂ¹, the
projection onto the circle. The cylinder is itself the space in which
one can easily represent maps of (SÂ¹â€„â†’â€„â„). Each such map corresponds to
a section.

Let be

$$\begin{aligned}
g_1 : S^1    & \longrightarrow  S^1 \times \mathbb{R} \\
      \theta & \longmapsto      (\theta, 1)
\end{aligned}$$

$$\begin{aligned}
g_2 : S^1    & \longrightarrow  S^1 \times \mathbb{R} \\
      \theta & \longmapsto      (\theta, cos(\theta))
\end{aligned}$$

We have
fâ€…âˆ˜â€…gâ‚â€„=â€„fâ€…âˆ˜â€…gâ‚‚â€„=â€„id_(SÂ¹)

(TODO add diagrams for S1xR, g1 and g2)

A fiber is the preimage of a singleton. In the case of f above, for
every qâ€„âˆˆâ€„SÂ¹, f^(â€…âˆ’â€…1)(q) is the copy of the real line on the cylinder
that passes by q.

(TODO add diagram)

Alternative characterization of a bijection

"f is bijective" â‡” ("every element of B has a non-empty fiber"
(surjection) and "every fiber is a singleton" (injection))

On monomorphisms and epimorphisms

Failing the mono/epi condition

Example of failing the monomorphism definition for a non-injection

Monomorphism definition:

$$\text{$f : A \to B$ is a monomorphism}
\\ \Leftrightarrow \\
\forall Z \in \text{Obj}(\mathcal{C}), \;
\forall g_1, g_2 \in \text{Hom}(Z, A), \;
(f \circ g_1 = f \circ g_2 \Rightarrow g_1 = g_2)$$

Aâ€„=â€„{a,â€†b,â€†c}
Bâ€„=â€„{1,â€†2}
Zâ€„=â€„{x,â€†y}
fâ€„:â€„Aâ€„â†’â€„Bâ€„=â€„{(a,â€†1),â€†(b,â€†1),â€†(c,â€†2)}, not injective

gâ‚â€„:â€„Zâ€„â†’â€„Aâ€„=â€„{(x,â€†a),â€†(y,â€†c)}
gâ‚‚â€„:â€„Zâ€„â†’â€„Aâ€„=â€„{(x,â€†b),â€†(y,â€†c)}

fâ€…âˆ˜â€…gâ‚â€„=â€„fâ€…âˆ˜â€…gâ‚‚â€„=â€„{(x,â€†1),â€†(y,â€†2)}â€„âˆˆâ€„(Zâ€„â†’â€„B)

The multiple choice of elements (here, a and b) in A which map to 1 in B
is precisely what allows the overall composition to be equal, even when
gâ‚â€„â‰ â€„gâ‚‚. This provides insight into a proof of "f is a monomorphism
implies that f is an injection". If you suppose that f is a monomorphism
and not an injection, you can easily reach a contradiction, since you
can use elements like 1 and 2 that both map to the same a to construct a
counter-example to the implication that defines a monomorphism.

Example of failing the epimorphism definition for a non-surjection

Epimorphism definition:

$$\text{$f : A \to B$ is an epimorphism}
\\ \Leftrightarrow \\ 
\forall Z \in \text{Obj}(\mathcal{C}), \;
\forall g_1, g_2 \in \text{Hom}(B, Z), \;
(g_1 \circ f = g_2 \circ f \Rightarrow g_1 = g_2)$$

gâ‚â€„:â€„Zâ€„â†’â€„Aâ€„=â€„{(x,â€†a),â€†(y,â€†c)}
gâ‚‚â€„:â€„Zâ€„â†’â€„Aâ€„=â€„{(x,â€†b),â€†(y,â€†c)}

fâ€…âˆ˜â€…gâ‚â€„=â€„fâ€…âˆ˜â€…gâ‚‚â€„=â€„{(x,â€†1),â€†(y,â€†2)}â€„âˆˆâ€„(Zâ€„â†’â€„B)

Aâ€„=â€„{a,â€†b}
Bâ€„=â€„{1,â€†2,â€†3}
Zâ€„=â€„{x,â€†y}
fâ€„:â€„Aâ€„â†’â€„Bâ€„=â€„{(a,â€†1),â€†(b,â€†2)}, not surjective

gâ‚â€„:â€„Bâ€„â†’â€„Zâ€„=â€„{(1,â€†x),â€†(2,â€†y),â€†(3,â€†x)}
gâ‚‚â€„:â€„Bâ€„â†’â€„Zâ€„=â€„{(1,â€†x),â€†(2,â€†y),â€†(3,â€†y)}

gâ‚â€…âˆ˜â€…fâ€„=â€„gâ‚‚â€…âˆ˜â€…fâ€„=â€„{(a,â€†x),â€†(b,â€†y)}â€„âˆˆâ€„(Aâ€„â†’â€„Z)

The element 3 in B not being reached by f is precisely that which
provides the opportunity to build gâ‚â€„â‰ â€„gâ‚‚ such that they compose to the
same result with f, since the output of 3 for them doesnâ€™t affect the
overall composition. This provides insight into a proof of "f is an
epimorphism implies that f is a surjection". If you suppose that f is an
epimorphism and not a surjection, you can easily reach a contradiction,
since you can use elements like 3 that are not reached by f to construct
a counter-example to the implication that defines an epimorphism.

Proofs of mono/inj and epi/surj equivalence

Let fâ€„:â€„Aâ€„â†’â€„B.

The parts which are "Injection => Monomorphism" and "Surjection =>
Epimorphism" both use the respective sided inverses to prove the
implication.

The other parts use the following tautology to prove the implication by
contradiction. "Suppose that p and Â¬q, show that it leads to a
contradiction".

(pâ€„â‡’â€„q)â€„â‡”â€„((Â¬p)â€…âˆªâ€…q)â€„â‡”â€„(Â¬(pâ€…âˆ©â€…Â¬q))

Injection => Monomorphism

Suppose that f is an injection. It thus has post-inverses.

âˆƒgâ€„âˆˆâ€„(Bâ€„â†’â€„A),â€†gâ€…âˆ˜â€…fâ€„=â€„id_(A)

From there:

âˆ€Zâ€„âˆˆâ€„Obj(ğ’),â€…âˆ€a,â€†bâ€„âˆˆâ€„Hom(Z,â€†A),
$$\begin{array}{ccccc} \\
f \circ a = f \circ b & \Rightarrow &  g \circ (f  \circ a) &=&  g \circ (f  \circ b) \\
                      & =           & (g \circ  f) \circ a  &=& (g \circ  f) \circ b  \\
                      & =           &         id_A \circ a  &=&         id_A \circ b  \\
                      & =           &                    a  &=&                    b
\end{array}$$

We conclude that f is also a monomorphism.

Surjection => Epimorphism

Suppose that f is a surjection. It thus has pre-inverses.

âˆƒgâ€„âˆˆâ€„(Bâ€„â†’â€„A),â€†fâ€…âˆ˜â€…gâ€„=â€„id_(B)

From there:

âˆ€Zâ€„âˆˆâ€„Obj(ğ’),â€…âˆ€a,â€†bâ€„âˆˆâ€„Hom(B,â€†Z),
$$\begin{array}{ccccc} \\
a \circ f = b \circ f & \Rightarrow & (a \circ  f) \circ g  &=& (b \circ  f) \circ g  \\
                      & =           &  a \circ (f  \circ g) &=&  b \circ (f  \circ g) \\
                      & =           &  a \circ  id_B        &=&  b \circ  id_B        \\
                      & =           &  a                    &=&  b
\end{array}$$

We conclude that f is also an epimorphism.

Monomorphism => Injection

Suppose that f is a monomorphism.

âˆ€Zâ€„âˆˆâ€„Obj(ğ’),â€…âˆ€gâ‚,â€†gâ‚‚â€„âˆˆâ€„Hom(Z,â€†A),â€…fâ€…âˆ˜â€…gâ‚â€„=â€„fâ€…âˆ˜â€…gâ‚‚â€„â‡’â€„gâ‚â€„=â€„gâ‚‚

Suppose now that f is not an injection. Algebraically, this means that:

âˆƒ(x,â€†y)â€„âˆˆâ€„AÂ²,â€† such that xâ€„â‰ â€„y and f(x)â€„=â€„f(y)

We can construct gâ‚ and gâ‚‚ such that fâ€…âˆ˜â€…gâ‚â€„=â€„fâ€…âˆ˜â€…gâ‚‚ but gâ‚â€„â‰ â€„gâ‚‚, using
such a pair (x,â€†y). Thereby, we prove that f is not an monomorphism and
arrive at a contradiction.

(If Z is the empty set, being initial in Set, there is only 1 map into A
(the empty map) and aâ€„=â€„b always hold. Therefore, any counterexample to
the epimorphism definition needs to have at least 1 element.)

Let Zâ€„=â€„{a}.

gâ‚(a)â€„=â€„x
gâ‚‚(a)â€„=â€„y

Clearly, gâ‚â€„â‰ â€„gâ‚‚. However, we also have:

f(gâ‚(a))â€„=â€„f(x)â€„=â€„f(y)â€„=â€„f(gâ‚‚(a))â€„â‡’â€„fâ€…âˆ˜â€…gâ‚â€„=â€„fâ€…âˆ˜â€…gâ‚‚

This means that f is not a monomorphism: contradiction.

Conclusion: f is an injection.

Epimorphism => Surjection

Suppose that f is an epimorphism.

âˆ€Zâ€„âˆˆâ€„Obj(ğ’),â€…âˆ€gâ‚,â€†gâ‚‚â€„âˆˆâ€„Hom(B,â€†Z),â€…gâ‚â€…âˆ˜â€…fâ€„=â€„gâ‚‚â€…âˆ˜â€…fâ€„â‡’â€„gâ‚â€„=â€„gâ‚‚

Suppose now that f isnâ€™t a surjection. Algebraically, this means that:

âˆƒxâ€„âˆˆâ€„B,â€†xâ€„âˆ‰â€„f(A)

We can construct gâ‚ and gâ‚‚ such that gâ‚â€…âˆ˜â€…fâ€„=â€„gâ‚‚â€…âˆ˜â€…f but gâ‚â€„â‰ â€„gâ‚‚, using
such an xâ€„âˆ‰â€„f(A). Thereby, we prove that f is not an epimorphism and
arrive at a contradiction.

(If Z is the singleton set, being terminal in Set, there is only 1 map
into Z and aâ€„=â€„b always hold. Therefore, any counterexample to the
epimorphism definition needs to have at least 2 elements. We will
however use a 3-element set, since it makes things more intuitive and
pedagogical.)

Let Zâ€„=â€„{a,â€†b,â€†c}.

$$g_1 =
\begin{cases}
    \forall x    \in f(A), g_1(x) = a \\
    \forall x \notin f(A), g_1(x) = b
\end{cases}$$

$$g_2 =
\begin{cases}
    \forall x    \in f(A), g_2(x) = a \\
    \forall x \notin f(A), g_2(x) = c
\end{cases}$$

Clearly, gâ‚â€„â‰ â€„gâ‚‚. However, since A is the domain of f, of gâ‚â€…âˆ˜â€…f, and of
gâ‚‚â€…âˆ˜â€…f, we have:

gâ‚â€…âˆ˜â€…fâ€„=â€„gâ‚‚â€…âˆ˜â€…fâ€„=â€„(xâ€„â†¦â€„a)â€„âˆˆâ€„(Aâ€„â†’â€„Z)

This means that f is not an epimorphism: contradiction.

Conclusion: f is a surjection.

Chapter 1, Section 3

Example summary

-   (3.2): Set, category of sets as objects and set functions as
    morphisms.

-   (3.3): preorder (or order, or equivalence relation) over a (single)
    set, transformed into a category; elements of the set as objects,
    and elements of the preorder (which is a relation, hence a subset of
    the cartesian product) as morphisms.

-   (3.4): the powerset with the inclusion operator, transformed into a
    category; elements of the powerset (i.e., subsets of the set) as
    objects, and inclusion relations as morphisms (this is just an
    example of a preorder / order / equivalence category seen in 3.3).

-   (3.5): slice categories ğ’_(A), categories which isolate a specific
    object A of a given category ğ’, and studies the morphisms into that
    object; an object of ğ’_(A) is any morphism from any arbitrary objet
    Z into A (not the homset Hom(Z,â€†A) itself !) and a morphism in ğ’_(A)
    (from zâ‚â€„âˆˆâ€„Zâ‚â€„â†’â€„A to zâ‚‚â€„âˆˆâ€„Zâ‚‚â€„â†’â€„A) is a "raising" Ïƒ_(A) into ğ’_(A) of
    a morphism Ïƒâ€„âˆˆâ€„Zâ‚â€„â†’â€„Zâ‚‚ in ğ’ that preserves composition on morphisms
    in ğ’ (i.e., zâ‚â€„=â€„zâ‚‚Ïƒâ€„â‡’â€„Ïƒ_(A)zâ‚â€„=â€„zâ‚‚).

-   (3.6): combining examples 3.3 and 3.5, first start with an order
    category on the set â„¤ (there is a morphism mâ€„â†’â€„n iff mâ€„â‰¤â€„n), then
    select a specific object (here, Aâ€„=â€„3) then study all morphisms of
    the category into A (so the relation nâ€„â‰¤â€„3 for any Zâ€„=â€„n); the
    morphisms Ïƒâ‚ƒâ€„=â€„(m,â€†3)â€„â†’â€„(n,â€†3) are then simply given by the
    transitivity of â‰¤, i.e., mâ€„â‰¤â€„nâ€„â‰¤â€„3 ((m,â€†3)â€„â†’â€„(n,â€†3) corresponds to
    mâ€„â‰¤â€„3â€„â‡’â€„nâ€„â‰¤â€„3, meaning our zâ‚â€„=â€„zâ‚‚Ïƒ transforming into Ïƒ_(A)zâ‚â€„=â€„zâ‚‚,
    here, corresponds to (mâ€„â‰¤â€„3)â€„=â€„(nâ€„â‰¤â€„3)â€…âˆ©â€…(mâ€„â‰¤â€„n) is transformed into
    (mâ€„â‰¤â€„3â€„â‡’â€„nâ€„â‰¤â€„3)â€…âˆ©â€…(mâ€„â‰¤â€„3)â€„â‡”â€„(nâ€„â‰¤â€„3)).

-   (3.7): coslice categories (morphisms out of a chosen object).

-   (3.8): the category Set^(â‹†) of pointed sets, a coslice category over
    Set and any singleton set {â€…â‹†â€…}. Objects in Set^(â‹†) are regular
    sets, but with a unique distinguished element; morphisms are any set
    functions that map the domainâ€™s distinguised element to the
    codomainâ€™s distinguished element.

-   (3.9): "bislice" and "bicoslice" categories, basically a similar
    construct as slice and coslice, but taking two objects of the
    starting category, and studying pairs of morphisms (from a common
    domain, resp codomain) into (resp from) this pair.

-   (3.10): "fibered bislice" and "fibered bicoslice" categories, once
    again a similair construct, but this time taking two morphisms into
    a common set C (resp. from a common set C).

On terminal and initial objects in Set

If $\empty$ is initial and {â€…â‹†â€…} is terminal, it is because a function
in Set (in categorical terms) must always have an output for every
input. Ie, in category theory, all functions are maps ("applications").

Said algebraically:

$$\forall A, B \in \text{Obj}(\bold{Set}), \;
\forall a \in A, \;
\forall f \in \text{Hom}(A, B), \;
\exists f(a) \in B$$

In the case of $\empty$ as the input set, and there is only one function
$f: \empty \to Z$ for any Z: f is the empty mapping. But any
$Z \to \empty$ (expept $\empty \to \empty$) contains no mapping (since
weâ€™d necessarily be ignoring at least one element of Z).

Similarly, in the case of the (unique up-to-isomorphism) singleton set
{â€…â‹†â€…} as the output, youâ€™d have multiple functions (precisely 2^(|Z|))
into it, if you could ignore some elements of the input set. However, if
all elements of the input set are required, that leaves you with only
one function possible from Zâ€„â†’â€„{â€…â‹†â€…}: the function which maps all
elements to â‹†.

Restrictions and extensions of functions, and its consequences on a functionâ€™s nature

8 possibilities to study, based on the following binary dichotomies:

-   injection or surjection

-   enlarging or restricting

-   domain or codomain

Note that enlarging the domain sometimes implies enlarging the codomain,
and restricting the codomain sometimes implies restricting the domain.

Legend: Yes, No, Depends

  ------------ ------------- -------------- ------------- --------------
                enlarge dom   restrict dom   enlarge cod   restrict cod
   injection         D             Y              Y             Y
   surjection        Y             D              N             Y
  ------------ ------------- -------------- ------------- --------------

Theorems:

A) if fâ€„âˆˆâ€„(Aâ€„â†’â€„B),â€†f injective (resp. surjective), then
âˆ€Zâ€„âŠ†â€„B,â€†fÌ‚â€„âˆˆâ€„((f^(â€…âˆ’â€…1)(Z)â€„âŠ†â€„A)â€„â†’â€„Z),â€†fÌ‚â€„=â€„f|_(f^(â€…âˆ’â€…1)(Z)), the
restriction of the function to the corresponding smaller codomain, is
also an injection (resp. surjection).

B) if fâ€„âˆˆâ€„(Aâ€„â†’â€„B),â€†f injective (resp. surjective), then
âˆ€Zâ€„âŠ‡â€„B,â€†fÌ‚â€„âˆˆâ€„(Aâ€„â†’â€„Z),â€†fÌ‚â€„=â€„Î¹â€…âˆ˜â€…f (with the Î¹ the canonical injection of
bâ€„âˆˆâ€„B into its superset Z), is also an injection (resp. is never a
surjection).

C) if fâ€„âˆˆâ€„(Aâ€„â†’â€„B),â€†f injective, then
âˆ€Zâ€„âŠ†â€„A,â€†fÌ‚â€„âˆˆâ€„(Zâ€„â†’â€„B),â€†fâ€„=â€„Î¹_((Zâ€„â†’â€„A))â€…âˆ˜â€…fÌ‚, we have that fÌ‚ is also an
injection. However, one can construct Zâ€„âŠ†â€„A such that f stops being a
surjection.

D) if fâ€„âˆˆâ€„(Aâ€„â†’â€„B),â€†f surjective, then
âˆ€Zâ€„âŠ‡â€„A,â€†fÌ‚â€„âˆˆâ€„(Zâ€„â†’â€„(Bâ€…âˆªâ€…f(Z))),â€†fâ€„=â€„Î¹_((Zâ€„â†’â€„A))â€…âˆ˜â€…fÌ‚, we have that fÌ‚ is
also a surjection. However, one can construct Zâ€„âŠ†â€„A such that f stops
being a injection.

Proof: TODO

On the morphisms of slice and coslice categories

Given a base category ğ’, and some set A we wish to study the homsets of
the slice (resp. coslice) category ğ’_(A) (resp. ğ’^(A). These homsets
might be empty, or have more than one element.

We remind that slice categories consider morphisms to A as their objects
(written as (Z,â€†Ï†) for any Ï†â€„:â€„Zâ€„â†’â€„A), while coslice categories consider
morphisms from A as their objects (written as (Ï†,â€†Z) for any Ï†â€„:â€„Aâ€„â†’â€„Z.
Morphisms, of the form Ïƒ_(A)â€„:â€„(Zâ‚,â€†Ï†â‚)â€„â†’â€„(Zâ‚‚,â€†Ï†â‚‚) (resp.
Ïƒ^(A)â€„:â€„(Ï†â‚,â€†Zâ‚)â€„â†’â€„(Ï†â‚‚,â€†Zâ‚‚)) in a slice category ğ’_(A) (resp. coslice
category ğ’^(A)) map such objects to one another if and only if there
exists a morphism in ğ’ (the base category!) such that Ï†â‚â€„=â€„Ï†â‚‚Ïƒ (resp.
ÏƒÏ†â‚â€„=â€„Ï†â‚‚).

Example of no Ïƒ for a slice category

For example, note that there exist pairs of morphisms fâ‚â€„âˆˆâ€„(Zâ‚â€„â†’â€„A) and
fâ‚‚â€„âˆˆâ€„(Zâ‚‚â€„â†’â€„A) between which there is no morphism that exists in the
slice category. One such example we can make is in (Vect_(â„))_(â„Â²). If
we take the maps:

$$f_1 = \begin{bmatrix} 1 & 0 \\ 0 & 0 \end{bmatrix} \in \mathcal{L}(\mathbb{R}^2)$$
$$f_2 = \begin{bmatrix} 0 & 0 \\ 0 & 1 \end{bmatrix} \in \mathcal{L}(\mathbb{R}^2)$$

There exists no map Ïƒ such that the following diagram commutes (since
the output of fâ‚ will always be null in its second coordinate, and the
output of fâ‚‚ will always be null in the first):

Example of no Ïƒ for a coslice category

TODO add potato diagram

Take Aâ€„=â€„Zâ‚‚â€„=â€„{a,â€†b,â€†c}, Ï†â‚‚â€„=â€„id_(A), and Zâ‚â€„=â€„{1,â€†2}. Since
|Zâ‚|â€„=â€„|dom(Ïƒ)|â€„<â€„|cod(Ïƒ)|â€„=â€„|Zâ‚‚|, there is no possible case in which
Im(Ïƒ)â€„=â€„Im(id_(A)) (even if Ï†â‚ is epi).

Example of multiple Ïƒ

TODO add potato diagram

Another example, this time in a coslice category, with Aâ€„=â€„{a,â€†b,â€†c}, we
take $\text{\textbf{Set}}_A$. We take Zâ‚â€„=â€„{1,â€†2,â€†3}, Zâ‚‚â€„=â€„{T,â€†F}. For
Ï†â‚â€„:â€„Aâ€„â†’â€„Zâ‚â€„=â€„{(a,â€†1),â€†(b,â€†1),â€†(c,â€†3)} and
Ï†â‚‚â€„:â€„Aâ€„â†’â€„Zâ‚‚â€„=â€„{(a,â€†T),â€†(b,â€†T),â€†(c,â€†F)} there exists two elements in
Hom_(ğ’®â„¯ğ“‰^(A))(Zâ‚,â€†Zâ‚‚). These originate from two functions in Set:
Ïƒ_(Î±)â€„=â€„{(1,â€†T),â€†(2,â€†T),â€†(3,â€†F)} and Ïƒ_(Î²)â€„=â€„{(1,â€†T),â€†(2,â€†F),â€†(3,â€†F)}.
The free element in 2â€„âˆˆâ€„Zâ‚ which is not in Im(Ï†â‚) offers a degree of
freedom.

Explanations on the conditions for Ïƒ

In the first example, what causes the issue is the fact that the images
of fâ‚ and fâ‚‚ in A are distinct.

In the second example, what causes the issue is the fact that weâ€™ve
reduced our common domain A to an insufficient intermediary object Zâ‚.

The "element which isnâ€™t mapped to offers a degree of freedom and thus
breaks unicity" in the last example should remind you of the notes on
surjections. Indeed, when comparing Ïƒ_(Î±) and Ïƒ_(Î²), weâ€™re in a context
which is reminiscent of the definition of an epimorphism.

Ï†â‚‚â€„=â€„Ïƒ_(Î±)Ï†â‚â€„=â€„Ïƒ_(Î±)Ï†â‚

We can be assured of being able to cancel Ï†1 iff Ï†â‚ is an epimorphism,
and thus Ïƒ, if it exists, is unique. The proof for slice categories is
similar, but given the reverse orders, uses monomorphisms.

More generally:

-   a) in a slice category, there will be no Ïƒ if Im(Ï†â‚)â€„â‰ â€„Im(Ï†â‚‚) (proof
    ? and in more general categories than concrete categories ? TODO:
    iff ?)

-   b) in a coslice category, there will be no Ïƒ if
    Pr(Im(Ï†â‚)â€„â‰ â€„Pr(Im(Ï†â‚‚)) (proof ? and in more general categories than
    concrete categories ? TODO: iff ?)

-   c) in a slice category, there is at most a single Ïƒ iff Ï†â‚‚ is mono

-   d) in a coslice category, there is at most a single Ïƒ iff Ï†â‚ is epi

(see perhaps https://ncatlab.org/nlab/show/over+category and
https://ncatlab.org/nlab/show/under+category )

Chapter 1, Section 4

Notes on counterintuitive rules

-   in some categories (such as â„¤ with â‰¤; or Ring), "mono and epi" does
    not imply "iso"

-   in every abelian category, we have that "iso â‡” epi and mono" (and
    though Set is not abelian, the property still holds)

-   while in Set, a function is an epimorphism (surjective) iff it has a
    pre-inverse, in Grp, some epimorphisms do not have right inverses.

Chapter 1, Section 5

Initial and terminal objects

-   there are categories without either initial or terminal objects,
    such as the preorder category of â„¤ with â‰¤.

-   there are categories with multiple initial or terminal objects (for
    example, in Set, every singleton set is a terminal object); however,
    these are respectively unique up to isomorphism

-   any object which is both initial and terminal is called a zero
    object.

Universal properties

"Normal" universal properties

Verbatim: "The most natural context in which to introduce universal
properties requires a good familiarity with the language of functors,
which we will only introduce at a later stage. [...] We say that a
construction satisï¬es a universal property (or: â€™is the solution to a
universal problemâ€™) when it may be viewed as a terminal object of a
category."

Then: "The declaration/explanation of a universal property generally
follows the pattern â€™object X is universal with respect to the following
property: for any Y such that..., there exists a unique morphism Y â†’ X
such that...â€™; this explanation hides the deï¬nition of an accessory
category, and the statement that X is terminal."

This is a complicated way to say: there is some construct to decompose a
morphism which is "universal" (always exists) and reduces the rest of
the information of the morphism into something "unique" (hence terminal
object of some subcategory).

Dual universal properties

Lexicon

Chapter 1

Section 1

-   Set (not a multiset)

-   âˆ…: the empty set, containing no elements;

-   â„•: the set of natural numbers (that is, nonnegative integers);

-   â„¤: the set of integers;

-   â„š: the set of rational numbers;

-   â„: the set of real numbers;

-   â„‚: the set of complex numbers.

-   Singleton:

-   âˆƒ: existential quantifier, "there exists"

-   âˆ€: universal quantifier, "for all"

-   inclusion:

-   subset:

-   cardinal:

-   powerset:

-   âˆª: the union:

-   âˆ©: the intersection:

-   $\\$: the difference:

-   âˆ: the disjoint union:

-   Ã—: the (Cartesian) product:

-   complement of a subset

-   relation

-   order relation

-   equivalence relation

-   reflexivity

-   symmetry

-   antisymmetry

-   transitivity

-   partition

-   /âˆ¼: quotient by an equivalence relation

Section 2

-   function

-   graph

-   (categorical, function) diagram

-   identity function

-   kernel (of a function)

-   image (of a function)

-   restriction (of a function to a subset)

-   multiset

-   composition

-   commutative (diagram)

-   injection

-   surjection

-   bijection

-   isomorphism

-   inverse

-   pre-inverse, right-inverse

-   post-inverse, left-inverse

-   monomorphism

-   epimorphism

-   natural projection

-   natural injection

-   canonical decomposition (of a function)

Section 3

-   category

-   object

-   morphism

-   endomorphism

-   operation

-   discrete category

-   small category

-   locally small category

-   slice category

-   coslice category

-   comma category (mentioned, undefined)

-   pointed set

-   C^(A,â€†B) category ?? (bislice, bicoslice, fibered bislice, fibered
    bicoslice)

-   dual category

Section 4

-   automorphism

Section 5

-   universal property

-   initial object

-   final object

-   terminal object

-   (categorical) product

-   (categorical) coproduct

-   (categorical) pullback / fibered product

-   (categorical) pushout / fibered coproduct

-   (set) pullback / fibered product

-   (set) pushout / fibered coproduct
