<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Multiversity Algebra Chapter 0 Reading Group" />
  <title>Aluffi_AC0.en</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="/usr/share/javascript/mathjax/tex-mml-chtml.js" type="text/javascript"></script>
</head>
<body>
<h1 id="summaries">Summaries</h1>
<p>Chapter I)</p>
<p>Section 1) Explains fundamentals of set theory and basic set operations</p>
<p>Section 2) Explains set relations, set functions and some more advanced set operations</p>
<p>Section 3) Presents categories, and multiple examples of categories. Some are simple, some are advanced.</p>
<p>Section 4) Presents monomorphisms and epimorphisms in more detail, taking care to distinguish general morphisms from set functions and their accolytes (inj, surj, etc)</p>
<p>Section 5) Presents more advanced concepts from category theory, mostly some important universal properties</p>
<p>Chapter II)</p>
<h1 id="group-weekly-reports">Group Weekly Reports</h1>
<p>Week 1 : Today we mostly talked about the first chapter first section’s reading; going over the vocabulary term by term (see the lexicon on the github repo), and going more in depth over certain concepts (particularly relating to set relations). We also saw a bit of a "teaser" of how these notions are used. We did not go over the exercises since not everyone had done them.</p>
<p>Week 2 : Today we continued on discussing the first chapter, it was mostly freeform. We mostly talked about foundations of set theory (mostly stemming from the discussion of exercise 1 on russell’s paradox), why we use function notation the way we do, and about some of the operators over sets themselves (including through some examples from linear algebra and things like the subobject classifier which is seen at the end of section 3).</p>
<p>Week 3 : Today we finished discussing the first chapter. We went over all exercises. We mostly spoke about equivalence relations and partitions. We also spoke about the geometry/topology of quotients of sets by equivalence relations. This was naturally related to exercises 1.2 to 1.7.</p>
<p>Week 4 : We went over monomorphisms and epimorphisms in more depth. We corrected exercises 2.1 to 2.3 (included)</p>
<p>Week 5 : We went in depth over the distinction between isomorphisms and bijections (foreshadowing a bunch of category theory while we were at it) and corrected exercises 2.4 and 2.5.</p>
<p>Week 6 : We went in depth over the notion of section. We corrected exercises 2.6 and 2.7. For the latter exercise, we understood Tristan’s solution by ourselves ! (written by Amric)</p>
<p>Week 7 : We reviewed the notions of algebraic quotient and well-definition. We broached the notion of universal property. We used this to correct exercises 2.8 and 2.9.</p>
<p>Week 8 : We corrected exercises 2.10 and 2.11. We then did some preliminary explanations to present categories and help with the reading of section 3.</p>
<p>Week 9 : We spoke more in depth about category theory, concrete categories, local smallness, algebraic structures (and their vocabulary) and applied category theory.</p>
<p>Week 10 : We reviewed examples 3.2, 3.3, 3.4 and gave a bunch of disambiguation ideas for 3.5. Next week we’ll go over 3.5 and 3.6 in a bit more detail, and start correcting the exercises for this section. We’ll leave 3.7 and above for when we get to their respective exercises</p>
<h1 id="lexicon">Lexicon</h1>
<h2 class="unnumbered" id="chapter-1">Chapter 1</h2>
<h3 class="unnumbered" id="section-1">Section 1</h3>
<ul>
<li><p>Set (not a multiset)</p></li>
<li><p>∅: the empty set, containing no elements;</p></li>
<li><p>N: the set of natural numbers (that is, nonnegative integers);</p></li>
<li><p>Z: the set of integers;</p></li>
<li><p>Q: the set of rational numbers;</p></li>
<li><p>R: the set of real numbers;</p></li>
<li><p>C: the set of complex numbers.</p></li>
<li><p>Singleton:</p></li>
<li><p>∃: existential quantifier, "there exists"</p></li>
<li><p>∀: universal quantifier, "for all"</p></li>
<li><p>inclusion:</p></li>
<li><p>subset:</p></li>
<li><p>cardinal:</p></li>
<li><p>powerset:</p></li>
<li><p>∪: the union:</p></li>
<li><p>∩: the intersection:</p></li>
<li><p><span class="math inline">\(\\\)</span>: the difference:</p></li>
<li><p><span class="math inline">\(\coprod\)</span>: the disjoint union:</p></li>
<li><p>×: the (Cartesian) product:</p></li>
<li><p>complement of a subset</p></li>
<li><p>relation</p></li>
<li><p>order relation</p></li>
<li><p>equivalence relation</p></li>
<li><p>reflexivity</p></li>
<li><p>symmetry</p></li>
<li><p>antisymmetry</p></li>
<li><p>transitivity</p></li>
<li><p>partition</p></li>
<li><p>quotient by an equivalence relation</p></li>
</ul>
<h3 class="unnumbered" id="section-2">Section 2</h3>
<ul>
<li><p>function</p></li>
<li><p>graph</p></li>
<li><p>(categorical, function) diagram</p></li>
<li><p>identity function</p></li>
<li><p>kernel (of a function)</p></li>
<li><p>image (of a function)</p></li>
<li><p>restriction (of a function to a subset)</p></li>
<li><p>multiset</p></li>
<li><p>composition</p></li>
<li><p>commutative (diagram)</p></li>
<li><p>injection</p></li>
<li><p>surjection</p></li>
<li><p>bijection</p></li>
<li><p>isomorphism</p></li>
<li><p>inverse</p></li>
<li><p>pre-inverse, right-inverse</p></li>
<li><p>post-inverse, left-inverse</p></li>
<li><p>monomorphism</p></li>
<li><p>epimorphism</p></li>
<li><p>natural projection</p></li>
<li><p>natural injection</p></li>
<li><p>canonical decomposition (of a function)</p></li>
</ul>
<h3 class="unnumbered" id="section-3">Section 3</h3>
<ul>
<li><p>category</p></li>
<li><p>object</p></li>
<li><p>morphism</p></li>
<li><p>endomorphism</p></li>
<li><p>operation</p></li>
<li><p>discrete category</p></li>
<li><p>small category</p></li>
<li><p>locally small category</p></li>
<li><p>slice category</p></li>
<li><p>coslice category</p></li>
<li><p>comma category (mentioned, undefined)</p></li>
<li><p>pointed set</p></li>
<li><p><span class="math inline">\(C^{A, B}\)</span> category ?? (bislice, bicoslice, fibered bislice, fibered bicoslice)</p></li>
<li><p>dual category</p></li>
</ul>
<h3 class="unnumbered" id="section-4">Section 4</h3>
<ul>
<li><p>automorphism</p></li>
</ul>
<h3 class="unnumbered" id="section-5">Section 5</h3>
<ul>
<li><p>universal property</p></li>
<li><p>initial object</p></li>
<li><p>terminal object</p></li>
<li><p>(categorical) product</p></li>
<li><p>(categorical) coproduct</p></li>
</ul>
<h1 id="exercise-solutions">Exercise solutions</h1>
<h2 class="unnumbered" id="chapter-i">Chapter I)</h2>
<h3 class="unnumbered" id="section-1-1">Section 1)</h3>
<h4 class="unnumbered" id="section">1.1)</h4>
<p>In a nutshell, Russell’s paradox proves, by contradiction, that certain mathematical collections cannot be sets. It posits the existence of a "set of all sets that don’t contain themselves". Such a set can neither contain itself (since in that case, it would be a "set that does contain itself", and should be excluded); nor can it exclude it itself (since in that case, it would be a "set that doesn’t contain itself", and should be included).</p>
<h4 class="unnumbered" id="section-6">1.2)</h4>
<p>Prove that any equivalence relation over a set <span class="math inline">\(S\)</span> defines a partition of <span class="math inline">\(\mathcal{P}_S\)</span>.</p>
<p>a) <span class="math inline">\(\mathcal{P}_S\)</span> has no empty elements: any element in <span class="math inline">\(S\)</span> is part of at least one equivalence class, the class containing at least that element itself. Since there is no equivalence class constructed independently from elements, there are no empty equivalence classes.</p>
<p>b) Elements of <span class="math inline">\(\mathcal{P}_S\)</span> are disjoint: suppose there is an element <span class="math inline">\(x\)</span> that is part of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, two distinct equivalence classes. <span class="math inline">\(\forall a \in A, x \sim a\)</span> and <span class="math inline">\(\forall b \in B, x \sim b\)</span>. By transivity through <span class="math inline">\(x\)</span>, <span class="math inline">\(\forall a \in A, \forall b \in B, a \sim b\)</span>. Therefore, <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are the same equivalence class: <span class="math inline">\(A = B\)</span>. Contradiction. Therefore all elements of <span class="math inline">\(\mathcal{P}_S\)</span> are disjoint subsets of <span class="math inline">\(S\)</span>.</p>
<p>c) The union of all elements of <span class="math inline">\(\mathcal{P}_S\)</span> makes up <span class="math inline">\(S\)</span>: suppose <span class="math inline">\(\exists x \in S\)</span> such that <span class="math inline">\(x \notin \bigcup_{S_i \in \mathcal{P}_S} S_i\)</span>. From the argument made in (a), <span class="math inline">\(x\)</span> exists in at least one equivalence class, the class which contains only <span class="math inline">\(x\)</span> itself. This is one of ou <span class="math inline">\(S_i\)</span> sets. Contradiction. Therefore, <span class="math inline">\(\bigcup_{S_i \in \mathcal{P}_S} S_i = S\)</span></p>
<h4 class="unnumbered" id="section-7">1.3)</h4>
<p>Given a partition <span class="math inline">\(\mathcal{P}\)</span> on a set <span class="math inline">\(S\)</span>, show how to define a relation <span class="math inline">\(\sim\)</span> on <span class="math inline">\(S\)</span> such that <span class="math inline">\(P\)</span> is the corresponding partition.</p>
<p>The insight here is to build an equivalence relation such that two elements are equivalent if and only if they are part of the same subset of <span class="math inline">\(S\)</span>, which is understood as their common equivalence class.</p>
<p>We define <span class="math inline">\(\sim\)</span> such that <span class="math inline">\(\forall S_i, S_j \in \mathcal{P}, \forall x \in S_i, \forall y \in S_j, x \sim y \Leftrightarrow S_i = S_j\)</span>.</p>
<p>Let us prove that <span class="math inline">\(\sim\)</span> is an equivalence relation.</p>
<p>a) Reflexivity: <span class="math display">\[\forall A \in \mathcal{P}, \forall x \in A, A = A \Rightarrow x \sim x\]</span></p>
<p>b) Symmetry: <span class="math display">\[\forall S_i, S_j \in \mathcal{P}, \forall x \in S_i, \forall y \in S_j, x \sim y \Leftrightarrow S_i = S_j \Leftrightarrow S_j = S_i \Leftrightarrow y \sim x\]</span></p>
<p>c) Transitivity:</p>
<p><span class="math display">\[\begin{aligned}
\forall S_i, S_j, S_k \in \mathcal{P}, \forall x \in S_i, \forall y \in S_j, \forall z \in S_k, \\
(x \sim y) \cap (y \sim z) \\
    \Leftrightarrow \\
(S_i = S_j) \cap (S_j = S_k) \\
    \Rightarrow \\
S_i = S_k \\
    \Leftrightarrow \\
x \sim z
\end{aligned}\]</span></p>
<p>Therefore, <span class="math inline">\(\sim\)</span> is indeed an equivalence relation, and is generated uniquely by the partition.</p>
<h4 class="unnumbered" id="section-8">1.4)</h4>
<p>How many different equivalence relations may be defined on the set <span class="math inline">\(\{1, 2, 3\}\)</span>?</p>
<p>If we start with the 1 element set, we have only one possible partition, one possible equivalence class.</p>
<p>With the 2 element set, there are 2 partitions, <span class="math inline">\(\{\{1, 2\}\}\)</span> and <span class="math inline">\(\{\{1\}, \{2\}\}\)</span>.</p>
<p>With the 3 element set, there is:</p>
<ul>
<li><p>1 partition of type 1-1-1: <span class="math inline">\(\{\{1\}, \{2\}, \{3\}\}\)</span>.</p></li>
<li><p>3 partitions of type 2-1: <span class="math inline">\(\{\{1\}, \{2, 3\}\}\)</span>, <span class="math inline">\(\{\{2\}, \{1, 3\}\}\)</span>, and <span class="math inline">\(\{\{3\}, \{1, 2\}\}\)</span>.</p></li>
<li><p>1 partition of type 3: <span class="math inline">\(\{\{1, 2, 3\}\}\)</span>.</p></li>
</ul>
<p>Hence, there are five equivalence classes on the 3 element set.</p>
<p>See the Bell numbers: https://oeis.org/A000110</p>
<h4 class="unnumbered" id="section-9">1.5)</h4>
<p>Give an example of a relation that is reflexive and symmetric, but not transitive. What happens if you attempt to use this relation to define a partition on the set?</p>
<p>Let’s imagine a "similarity relation" we can notate with <span class="math inline">\(\simeq\)</span>. We can imagine it to work like a looser version of equality (say for example, if an integer is only <span class="math inline">\(1\)</span> away, then it counts as similar).</p>
<ul>
<li><p>reflexive: <span class="math inline">\(\forall a \in S, a \simeq a\)</span> (an element is always "similar" to itself)</p></li>
<li><p>symmetric: <span class="math inline">\(\forall a, b \in S, a \simeq b \Rightarrow b \simeq a\)</span> ("similarity" goes both ways)</p></li>
<li><p>not transitive: <span class="math inline">\(\exists a, b, c \in S, (a \simeq b) \land (b \simeq c) \land \lnot (a \simeq c)\)</span> (just because <span class="math inline">\(a \simeq b\)</span> and <span class="math inline">\(b \simeq c\)</span> are similar, that doesn’t mean <span class="math inline">\(a \simeq c\)</span> works, because it is possible for the "similarity gap" to be too large to qualify as "similar". E.g.: <span class="math inline">\((a, b, c) = (1, 2, 3)\)</span>.).</p></li>
</ul>
<p>If we use this to define a partition <span class="math inline">\(P\)</span> on some set <span class="math inline">\(S\)</span>: <span class="math inline">\(S/\simeq := P_\simeq\)</span>, there is ambiguity as to which element should go into which equivalence class.</p>
<p>This idea deserves further discussion.</p>
<p>In terms of graph theory, if we express a set with an internal relation as a graph, we can represent elements as nodes and relationships as edges. Reflexivity means that every node has a loop (unary, self-edge). Symmetry means that the graph is not directed (since every relationship goes both ways). Transitivity means that every connected subset of nodes is a maximal clique (synonymously, every connected component is a complete subgraph).</p>
<p>In a relation which is reflexive and symmetric, but not transitive, you would have connected components of this graph which are not cliques. For these, there is ambiguity as to how you would group their nodes. Two obvious choices would be either:</p>
<ul>
<li><p>to remove the minimal number of edges to obtain n distinct cliques (thereby gaining the <em>transitive restriction</em> of the relation) from a given non-clique; or</p></li>
<li><p>to complete the connected subgraph into a clique (thereby gaining the <em>transitive closure</em> of the relation).</p></li>
</ul>
<h4 class="unnumbered" id="section-10">1.6)</h4>
<p>Define a relation <span class="math inline">\(\sim\)</span> on the set <span class="math inline">\(\mathbb{R}\)</span> of real numbers, by setting <span class="math inline">\(a \sim b \Leftrightarrow b - a \in \mathbb{Z}\)</span>. Prove that this is an equivalence relation, and find a ’compelling’ description for <span class="math inline">\(\mathbb{R}/\sim\)</span>. Do the same for the relation <span class="math inline">\(\approx\)</span> on the plane <span class="math inline">\(\mathbb{R} \times \mathbb{R}\)</span> defined by declaring <span class="math inline">\((a_1, a_2) \approx (b_1, b_2) \Leftrightarrow b_1 - a_1 \in \mathbb{Z} \text{ and } b_2 - a_2 \in \mathbb{Z}\)</span>.</p>
<p>TODO: forgot to prove that it’s an equivalence relation</p>
<p><span class="math inline">\(b - a \in \mathbb{Z}\)</span> means that 2 real numbers differ by an integral amount. This means that the equivalence relation algebraically describes the idea that "with this relation, 2 real numbers are the same iff they have the same fractional component <span class="math inline">\(x\)</span> (or <span class="math inline">\(1 - x\)</span> for negative numbers)". Eg, <span class="math inline">\(4.76 \sim 1024.76 \sim -5.34\)</span>, since <span class="math inline">\(-5.34 + 10 = 4.76\)</span>, etc.</p>
<p>To make an algebraic quotient of a set by an equivalence relation, we take the function which maps each element to its corresponding equivalence class, in the set (partition) containing these equivalence class. Intuitively, this is similar to keeping only one representative element per equivalence class. For the example class above, we can keep the representative <span class="math inline">\(0.76\)</span>. There is such an equivalence class for every fractional part possible, that is, one for every number in <span class="math inline">\([0, 1[\)</span>. The corresponding map is the "real remainder of division modulo 1". This map is well-defined because each real number has only one output for this map, and all real numbers that are equivalent through <span class="math inline">\(\sim\)</span> are mapped to the same value in the output set.</p>
<p>We should also notice that since <span class="math inline">\(0 \sim 1\)</span>, this space loops around on itself. Intuitively, if you increase linearly in the input space <span class="math inline">\(\mathbb{R}\)</span>, it goes back to <span class="math inline">\(0\)</span> after <span class="math inline">\(0.9999999...\)</span> in the output space. This output space is thus a circle of perimeter <span class="math inline">\(1\)</span>.</p>
<p>Similarly, <span class="math inline">\(b_1 - a_1 \in \mathbb{Z} \text{ and } b_2 - a_2 \in \mathbb{Z}\)</span> means that 2 points in the 2D plane are the same iff they differ in each coordinate by an integral amount. This boils down to combining two such loops from the first part of the exercise: one in the <span class="math inline">\(x\)</span> direction and one in the <span class="math inline">\(y\)</span> direction: what this gives is the small square <span class="math inline">\([0, 1[ \times [0, 1[\)</span>, which loops to <span class="math inline">\(x = 0\)</span> (resp. <span class="math inline">\(y = 0\)</span>) when <span class="math inline">\(x = 1\)</span> (resp. <span class="math inline">\(y = 1\)</span>) is reached. This space functions like a small torus, of area <span class="math inline">\(1\)</span>.</p>
<h3 class="unnumbered" id="section-2-1">Section 2)</h3>
<h4 class="unnumbered" id="section-11">2.1)</h4>
<p>How many different bijections are there between a set <span class="math inline">\(S\)</span> with <span class="math inline">\(n\)</span> elements and itself?</p>
<p>Any bijection is a choice of a pairs from 2 sets of the same size, where each element is used only once, and each pair has one element from each set. At first there are <span class="math inline">\(n\)</span> choices in each set. We go through each possible input element in order (no choice), for each one, we pick one amongst <span class="math inline">\(n\)</span> possibilities for an output.</p>
<p>There are then <span class="math inline">\((n-1)\)</span> choice of output left, etc.</p>
<p>Ccl°: <span class="math inline">\(\prod_{i=1}^{i=n} i = n!\)</span></p>
<h4 class="unnumbered" id="section-12">2.2)</h4>
<p>Prove that a function has a right-inverse (pre-inverse) iff it is surjective (can use AC).</p>
<p>Let <span class="math inline">\(f \in (A \to B)\)</span>.</p>
<h5 class="unnumbered" id="a-rightarrow">2.2.a) <span class="math inline">\(\Rightarrow\)</span></h5>
<p>Suppose that <span class="math inline">\(f\)</span> has a right-inverse (pre-inverse). We have <span class="math inline">\(\exists g \in (B \to A), f \circ g = id_B\)</span></p>
<p>Suppose that <span class="math inline">\(f\)</span> is not a surjection. This means <span class="math inline">\(\exists b \in B, \nexists a \in A, b = f(a)\)</span></p>
<p><span class="math inline">\(f(g(b))= id_B (b) = b\)</span> Necessarily, <span class="math inline">\(g(b)\)</span> is such an <span class="math inline">\(a\)</span>, so <span class="math inline">\(\exists a \in A, b = f(a)\)</span>. Contradiction.</p>
<p>Ccl°:: f is a surjection.</p>
<h5 class="unnumbered" id="b-leftarrow">2.2.b) <span class="math inline">\(\Leftarrow\)</span></h5>
<p>Suppose that f is a surjection.</p>
<p><span class="math inline">\(\forall b \in B, \exists a \in A, b = f(a)\)</span></p>
<p>We will construct a pre-inverse for <span class="math inline">\(f\)</span>.</p>
<p>The insight here is to realize that a surjection divides its input set into a partition, where each 2-by-2 disjoint subset corresponds to <span class="math inline">\(f^{-1}(\{q\})\)</span>, for every <span class="math inline">\(q\)</span> in the output set. More formally, each "fiber" (preimage of a singleton) is a disjoint subset of the input set, and the union of fibers is the input set itself. You can see this in the following diagram:</p>
<p>(add diagram) 1234 to ab 1a 2a (fiber from a) 3b 4b (fiber from b) https://tex.stackexchange.com/questions/157450/producing-a-diagram-showing-relations-between-sets https://tex.stackexchange.com/questions/79009/drawing-the-mapping-of-elements-for-sets-in-latex</p>
<p>Using AC, we select a single element from each such fiber. For each <span class="math inline">\(q \in B\)</span>, we name <span class="math inline">\(p_q \in f^{-1}(\{q\})\)</span> the chosen element. We define <span class="math inline">\(g\)</span> as <span class="math inline">\(g \in (B \to A), g = (q \mapsto p_q)\)</span>. With this, <span class="math inline">\(\forall b \in B, f \circ g (b) = b\)</span>, and so <span class="math inline">\(f \circ g = id_A\)</span>. Thus, <span class="math inline">\(f\)</span> has a preinverse.</p>
<p>A summary of this idea: all surjection preinverses are simply a choice of a representative for each fiber of the surjection as the output to the respective singleton.</p>
<h4 class="unnumbered" id="section-13">2.3)</h4>
<p>Prove that the inverse of a bijection is a bijection, and that the composition of two bijections is a bijection.</p>
<h5 class="unnumbered" id="a">2.3.a)</h5>
<p>Using the fact that a function is a bijection iff it has a two-sided inverse (Corollary 2.2) we can see from this defining fact, <span class="math inline">\(f \in (A \to B) \text{ bijective } \Leftrightarrow \exists f^{-1} \in (B \to A), (f^{-1} \circ f = id_A \text { and } f \circ f^{-1} = id_B)\)</span> that <span class="math inline">\(f\)</span> is naturally <span class="math inline">\(f^{-1}\)</span>’s (unique) two-sided inverse, and so <span class="math inline">\(f^{-1}\)</span> is also a bijection.</p>
<h5 class="unnumbered" id="b">2.3.b)</h5>
<p>Let be <span class="math inline">\(f \in (A \to B), g \in (B \to C)\)</span>, both bijective (hence with inverses in the respective function spaces). Let <span class="math inline">\(h \in (A \to C), h = g \circ f\)</span> and <span class="math inline">\(h^{-1} \in (C \to A), h^{-1} = f^{-1} \circ g^{-1}\)</span>. We have:</p>
<p><span class="math display">\[\begin{aligned}
h^{-1} \circ h &amp;= (f^{-1} \circ g^{-1}) \circ (g \circ f) \\
               &amp;=  f^{-1} \circ g^{-1}  \circ  g \circ f  \\
               &amp;=  f^{-1} \circ          id_B    \circ f  \\
               &amp;=  f^{-1} \circ                        f  \\
               &amp;=  id_A
\end{aligned}\]</span></p>
<p><span class="math display">\[\begin{aligned}
h \circ h^{-1} &amp;= (g \circ f) \circ (f^{-1} \circ g^{-1}) \\
               &amp;=  g \circ f  \circ  f^{-1} \circ g^{-1}  \\
               &amp;=  g \circ     id_B         \circ g^{-1}  \\
               &amp;=  g \circ                        g^{-1}  \\
               &amp;=  id_C
\end{aligned}\]</span></p>
<p>Therefore <span class="math inline">\(h\)</span> and <span class="math inline">\(h^{-1}\)</span> are two-sided inverses of each other, and thus bijections. From this we conclude that the composition of any two bijections is also a bijection.</p>
<h4 class="unnumbered" id="section-14">2.4)</h4>
<p>Prove that ‘isomorphism’ is an equivalence relation (on any set of sets).</p>
<h5 class="unnumbered" id="a-problem-statement">2.4.a) Problem statement</h5>
<p>Let <span class="math inline">\(\mathcal{A}\)</span> be a set of sets. We define the relation <span class="math inline">\(\simeq\)</span> between the elements of <span class="math inline">\(\mathcal{A}\)</span> as the following:</p>
<p><span class="math display">\[\forall X, Y \in \mathcal{A}, \; X \simeq Y \Leftrightarrow \text {there exists a bijection between $X$ and $Y$}\]</span></p>
<p>Let us show that <span class="math inline">\(\simeq\)</span> is an equivalence relation.</p>
<h5 class="unnumbered" id="b-reflexivity">2.4.b) Reflexivity</h5>
<p>For any set <span class="math inline">\(A \in \mathcal{A}\)</span>, the identity mapping on <span class="math inline">\(A\)</span> is a bijection. This means that <span class="math inline">\(\forall A \in \mathcal{A}, A \simeq A\)</span>, ie, <span class="math inline">\(\simeq\)</span> is reflexive.</p>
<h5 class="unnumbered" id="c-symmetry">2.4.c) Symmetry</h5>
<p><span class="math display">\[\begin{aligned}
\forall X, Y \in \mathcal{A}, \; X \simeq Y &amp; \Rightarrow \exists f      \in (X \to Y) \text{ bijective} \\
                                            &amp; \Rightarrow \exists f^{-1} \in (Y \to X) \text{ bijective} \\
                                            &amp; \Rightarrow Y \simeq X
\end{aligned}\]</span></p>
<p>Therefore, <span class="math inline">\(\simeq\)</span> is symmetric.</p>
<h5 class="unnumbered" id="d-transitivity">2.4.d) Transitivity</h5>
<p>Let be <span class="math inline">\(X, Y, Z \in \mathcal{A}\)</span>. Suppose that <span class="math inline">\(X \simeq Y\)</span> and <span class="math inline">\(Y \simeq Z\)</span>. This means <span class="math inline">\(\exists f \in (X \to Y), g \in (Y \to Z)\)</span>, both bijections. Let be <span class="math inline">\(h \in (X \to Z), h = g \circ f\)</span>. <span class="math inline">\(h\)</span> is also a bijection since the composition of two bijections is also a bijection (exercise 2.3).</p>
<p>The existence of <span class="math inline">\(h\)</span> implies <span class="math inline">\(X \simeq Z\)</span>.</p>
<p>Therefore <span class="math inline">\(\simeq\)</span> is transitive.</p>
<h5 class="unnumbered" id="e-conclusion">2.4.e) Conclusion</h5>
<p>Isomorphism, <span class="math inline">\(\simeq\)</span>, is a relation on an arbitrary set (of sets) which is always reflexive, symmetric and transitive. It is thus an equivalence relation.</p>
<h4 class="unnumbered" id="section-15">2.5)</h4>
<p>Formulate a notion of epimorphism and prove that epimorphisms and surjections are equivalent.</p>
<p>See "notes" file: section "Proofs of mono/inj and epi/surj equivalence".</p>
<h4 class="unnumbered" id="section-16">2.6)</h4>
<p>With notation as in Example 2.4, explain how any function <span class="math inline">\(f \in (A \to B)\)</span> determines a section of <span class="math inline">\(\pi_A\)</span>.</p>
<p>A section is the preinverse of a surjection. Here, the surjection in question is <span class="math inline">\(\pi_A\)</span> the projection of <span class="math inline">\(A \times B\)</span> onto <span class="math inline">\(A\)</span>.</p>
<p>Let <span class="math inline">\(f \in (A \to B)\)</span>.</p>
<p>We now consider the function which maps an input <span class="math inline">\(a \in A\)</span> of <span class="math inline">\(f\)</span> to its "geometric representation" (its coordinates in the enclosing space <span class="math inline">\(A \times B\)</span>, corresponding to a point of the graph <span class="math inline">\(\Gamma_f\)</span>). <span class="math display">\[\hat{f} \in (A \to (A \times B)), \hat{f} = ( \; a \mapsto (a, f(a)) \; )\]</span> We notice that <span class="math inline">\(\hat{f}(A) = \Gamma_f\)</span>.</p>
<p>Naturally, <span class="math inline">\(\pi_A \circ \hat{f} = (a \mapsto a) = id_A\)</span>, therefore, <span class="math inline">\(\hat{f}\)</span> is a pre-inverse (section) of <span class="math inline">\(\pi_A\)</span>.</p>
<p>This set of relationships can be expressed in the following commutative diagram:</p>
<p>PS: see "On sections and fibers" in the "notes" file for a worked example.</p>
<h4 class="unnumbered" id="section-17">2.7)</h4>
<p>Let <span class="math inline">\(f \in (A \to B)\)</span> be any function. Prove that the graph <span class="math inline">\(\Gamma_f\)</span> of <span class="math inline">\(f\)</span> is isomorphic to <span class="math inline">\(A\)</span>.</p>
<p>Using the elements from the previous exercise, we know that <span class="math inline">\(\hat{f}\)</span> is injective from <span class="math inline">\(A\)</span> into <span class="math inline">\(A \times B\)</span>. This property is inherited to any restriction of the codomain <span class="math inline">\(Z \subseteq A \times B\)</span>, and corresponding implied restriction of the domain to <span class="math inline">\(Y = \hat{f}^{-1}(Z) \subseteq A\)</span>. In particular, here, <span class="math inline">\(Y = A\)</span> and <span class="math inline">\(Z = \Gamma_f = \hat{f}(A)\)</span>. We now consider <span class="math inline">\(\overline{f} \in (A \to \Gamma_f), \overline{f} = (a \mapsto \hat{f}(a))\)</span>. We can see that <span class="math inline">\(\overline{f}\)</span> is injective from being a restriction of an injective function to a smaller codomain. We also know that <span class="math inline">\(\overline{f}\)</span> is surjective, since its domain is its image. Therefore, <span class="math inline">\(\overline{f}\)</span> is a bijection. This means that <span class="math inline">\(A \simeq \Gamma_f\)</span>.</p>
<h4 class="unnumbered" id="section-18">2.8)</h4>
<p>Describe as explicitly as you can all terms in the canonical decomposition of the function <span class="math inline">\(f \in (\mathbb{R} \to \mathbb{C})\)</span> defined by <span class="math inline">\(f = (r \mapsto e^{2 \pi i r})\)</span>. (This exercise matches one assigned previously, which one?)</p>
<p>Firstly, elements of <span class="math inline">\(\mathbb{R}\)</span> are equivalent by this map (they have the same output) if they vary by <span class="math inline">\(1\)</span> from each other. This is a reference to the equivalence relation <span class="math inline">\(\sim\)</span> in exercise 1.6. Therefore, we will use <span class="math inline">\(\mathbb{R}/\sim \; \simeq S^1\)</span> in our decomposition. Obviously, the map from <span class="math inline">\((\mathbb{R} \to \mathbb{R}/\sim)\)</span>, which maps each element of <span class="math inline">\(\mathbb{R}\)</span> to respective their equivalence class is a surjection (since there’s no empty equivalence class).</p>
<p>Secondly, as mentioned, we have a bijection <span class="math inline">\(\tilde{f}\)</span> between <span class="math inline">\(\mathbb{R}/\sim\)</span> and <span class="math inline">\(S^1\)</span>, the circle group of unit complex numbers, namely <span class="math inline">\(\tilde{f} = (x \mapsto e^{2 \pi i x}\)</span>, where each element <span class="math inline">\(x\)</span> of <span class="math inline">\(\mathbb{R}/\sim\)</span> can be understood to correspond to a (class representative) value in the interval <span class="math inline">\([0, 1[\)</span>.</p>
<p>Finally, we do the canonical injection of <span class="math inline">\(S^1\)</span> into its superset <span class="math inline">\(\mathbb{C}\)</span>.</p>
<h4 class="unnumbered" id="section-19">2.9)</h4>
<p>Show that if <span class="math inline">\(A \simeq A&#39;\)</span> and <span class="math inline">\(B \simeq B&#39;\)</span> , and further <span class="math inline">\(A \cap B = \emptyset\)</span> and <span class="math inline">\(A&#39; \cap B&#39; = \emptyset\)</span>, then <span class="math inline">\(A \cup B \simeq A&#39; \cup B&#39;\)</span>. Conclude that the operation <span class="math inline">\(A \coprod B\)</span> (as described in §1.4) is well-defined up to isomorphism.</p>
<p>We suppose the aforementioned.</p>
<p>Let <span class="math inline">\(f_A\)</span> be a bijection from <span class="math inline">\(A \to A&#39;\)</span>, and <span class="math inline">\(f_B\)</span> be a bijection from <span class="math inline">\(B \to B&#39;\)</span>.</p>
<p>We define the following:</p>
<p><span class="math display">\[f \in (A \cup B \to A&#39; \cup B&#39;),
\text{ such that }
\begin{cases}
    \forall a \in A, \; f(a) = f_A(a) \\
    \forall b \in B, \; f(b) = f_B(b)
\end{cases}\]</span></p>
<p>This function is a well-defined function, since <span class="math inline">\(A \cap B = \emptyset\)</span>: every element of the domain has one, and only one, possible image.</p>
<p>Similarly, we define:</p>
<p><span class="math display">\[g \in (A&#39; \cup B&#39; \to A \cup B),
\text{ such that }
\begin{cases}
    \forall a \in A&#39;, \; g(a) = f_A^{-1}(a) \\
    \forall b \in B&#39;, \; g(b) = f_B^{-1}(b)
\end{cases}\]</span></p>
<p>Similarly, because <span class="math inline">\(A&#39; \cap B&#39; = \emptyset\)</span>, <span class="math inline">\(g\)</span> is well-defined.</p>
<p>Let us study <span class="math inline">\(g \circ f\)</span>. We have: <span class="math display">\[\begin{cases}
    \forall a \in A, \; g(f(a)) = f_A^{-1}(f_A(a)) = a \\
    \forall b \in B, \; g(f(b)) = f_B^{-1}(f_B(b)) = b
\end{cases}\]</span></p>
<p>Hence, <span class="math inline">\(g \circ f = id_{A \cup B}\)</span>. Similarly, <span class="math inline">\(f \circ g = id_{A&#39; \cup B&#39;}\)</span>. Therefore, <span class="math inline">\(g = f^{-1}\)</span>, <span class="math inline">\(f\)</span> is a bijection, and <span class="math inline">\(A \cup B \simeq A&#39; \cup B&#39;\)</span>.</p>
<p>We’ll now do a shift in notation. Let be some arbitrary sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. Let be <span class="math inline">\(A_1, A_2, B_1, B_2\)</span> such that <span class="math inline">\(A_1 = \{ 1 \} \times A\)</span>, <span class="math inline">\(A_2 = \{ 2 \} \times A\)</span>, <span class="math inline">\(B_1 = \{ 1 \} \times B\)</span>, and <span class="math inline">\(B_2 = \{ 2 \} \times B\)</span>. This means <span class="math inline">\(A \simeq A_1\)</span>, <span class="math inline">\(A \simeq A_2\)</span>, <span class="math inline">\(B \simeq B_1\)</span>, and <span class="math inline">\(B \simeq B_2\)</span>. It also means <span class="math inline">\(A_1 \cap A_2 = \emptyset\)</span> and <span class="math inline">\(B_1 \cap B_2 = \emptyset\)</span>. From the above, this implies <span class="math inline">\(A_1 \cup B_1 \simeq A_2 \cup B_2\)</span>.</p>
<p>This means that the disjoint union of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is indeed well-defined, up to isomorphism: so long as 2 respective copies of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are made in a way that their intersection is empty, the 2 respective unions of 1 copy each will be isomorphic.</p>
<h4 class="unnumbered" id="section-20">2.10)</h4>
<p>Show that if <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are finite sets, then <span class="math inline">\(|B^A| = |B|^{|A|}\)</span>.</p>
<p>The number of <span class="math inline">\(|B^A|\)</span> functions in <span class="math inline">\(B^A = (A \to B)\)</span> can be counted in the following way.</p>
<p>For each element <span class="math inline">\(a\)</span> of <span class="math inline">\(A\)</span>, of which there are <span class="math inline">\(|A|\)</span>, we can pick any element of <span class="math inline">\(B\)</span> as the image; a total of <span class="math inline">\(|B|\)</span> choices per choice of <span class="math inline">\(a\)</span>. This means <span class="math inline">\(|B| \times ... \times |B|\)</span>, a total of <span class="math inline">\(|A|\)</span> times. Hence, <span class="math inline">\(|B^A| = |B|^{|A|}\)</span>.</p>
<h4 class="unnumbered" id="section-21">2.11)</h4>
<p>In view of Exercise 2.10, it is not unreasonable to use <span class="math inline">\(2^A\)</span> to denote the set of functions from an arbitrary set <span class="math inline">\(A\)</span> to a set with <span class="math inline">\(2\)</span> elements (say <span class="math inline">\(\mathbb{B} = \{0, 1\}\)</span>). Prove that there is a bijection between <span class="math inline">\(2^A\)</span> and the power set <span class="math inline">\(\mathcal{P}(A)\)</span> of <span class="math inline">\(A\)</span>.</p>
<p>Simply put, every subset <span class="math inline">\(A_i\)</span> of <span class="math inline">\(A\)</span> is built through a series of <span class="math inline">\(|A|\)</span> choices: for each element <span class="math inline">\(a\)</span> in <span class="math inline">\(A\)</span>, do we keep the element <span class="math inline">\(a\)</span> in our subset <span class="math inline">\(A_i\)</span> (output <span class="math inline">\(1\)</span>) or do we remove it (output <span class="math inline">\(0\)</span>) ? It is then easy to see that such a series of choices can easily be encoded as a unique function in <span class="math inline">\(A \to \mathbb{B}\)</span>. The totality of such series of choices thus corresponds both to the space <span class="math inline">\(A \to \mathbb{B}\)</span>, and to the powerset <span class="math inline">\(\mathcal{P}(A)\)</span>, and there is a bijection between the two.</p>
<h3 class="unnumbered" id="section-3-1">Section 3)</h3>
<h4 class="unnumbered" id="section-22">3.1)</h4>
<p>Let <span class="math inline">\(\mathcal{C}\)</span> be a category. Consider a structure <span class="math inline">\(\mathcal{C}^{op}\)</span> with:</p>
<ul>
<li><p><span class="math inline">\(Obj(\mathcal{C}^{op}) \coloneqq Obj(\mathcal{C})\)</span>;</p></li>
<li><p>for <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> objects of <span class="math inline">\(\mathcal{C}^{op}\)</span> (hence, objects of <span class="math inline">\(\mathcal{C}\)</span>), <span class="math inline">\(Hom_{\mathcal{C}^{op}} (A, B) \coloneqq Hom_{\mathcal{C}} (B, A)\)</span></p></li>
</ul>
<p>Show how to make this into a category.</p>
<h5 class="unnumbered" id="a-composition">3.1.a) Composition</h5>
<p>First, to make things clearer and more rigorous, let us distinguish composition in <span class="math inline">\(\mathcal{C}\)</span> as <span class="math inline">\(\circ\)</span> and composition in <span class="math inline">\(\mathcal{C}^{op}\)</span> as <span class="math inline">\(\star\)</span>. We define <span class="math inline">\(\star\)</span> as: <span class="math display">\[\begin{aligned}
    &amp; \forall f \in Hom_{\mathcal{C}^{op}} (B, A) = Hom_{\mathcal{C}} (A, B), \\
    &amp; \forall g \in Hom_{\mathcal{C}^{op}} (C, B) = Hom_{\mathcal{C}} (B, C), \\
    &amp; \exists h \in Hom_{\mathcal{C}^{op}} (C, A) = Hom_{\mathcal{C}} (A, C), \\
    &amp; f \star g \coloneqq g \circ f = h
\end{aligned}\]</span></p>
<p>We will now show that <span class="math inline">\(\mathcal{C}^{op}\)</span> with <span class="math inline">\(\star\)</span> verifies the other axioms of a category (namely identity and associativity of composition).</p>
<h5 class="unnumbered" id="b-identity">3.1.b) Identity</h5>
<p>Since <span class="math inline">\(\mathcal{C}\)</span> is a category, since <span class="math inline">\(\mathcal{C}^{op}\)</span> has the same objects, and since, by definition, for all object <span class="math inline">\(A\)</span>, we have <span class="math inline">\(Hom_{\mathcal{C}^{op}} (A, A) = Hom_{\mathcal{C}} (A, A)\)</span>, we can take every <span class="math inline">\(id_A \in Hom_{\mathcal{C}}(A, A)\)</span> as the same identity in <span class="math inline">\(\mathcal{C}^{op}\)</span>. We can verify that this is compatible with <span class="math inline">\(\star\)</span>:</p>
<p><span class="math display">\[\begin{aligned}
    \forall A, B &amp; \in Obj (\mathcal{C})        &amp;=&amp; \;  Obj (\mathcal{C}^{op})        , \\
    \exists id_A &amp; \in Hom_{\mathcal{C}} (A, A) &amp;=&amp; \;  Hom_{\mathcal{C}^{op}} (A, A) , \\
    \exists id_B &amp; \in Hom_{\mathcal{C}} (B, B) &amp;=&amp; \;  Hom_{\mathcal{C}^{op}} (B, B) , \\
    \forall f    &amp; \in Hom_{\mathcal{C}} (A, B) &amp;=&amp; \;  Hom_{\mathcal{C}^{op}} (B, A) , \\
    f            &amp; =   f    \circ id_A          &amp;=&amp; \;  id_A \star f                  , \\
    f            &amp; =   id_B \circ    f          &amp;=&amp; \;  f    \star id_B                 \\
\end{aligned}\]</span></p>
<h5 class="unnumbered" id="c-associativity">3.1.c) Associativity</h5>
<p>Using associativity in <span class="math inline">\(\mathcal{C}\)</span>, we have:</p>
<p><span class="math display">\[\begin{aligned}
    \forall A, B, C, D &amp; \in Obj (\mathcal{C})        &amp;=&amp; \;  Obj (\mathcal{C}^{op})        , \\
    \forall f          &amp; \in Hom_{\mathcal{C}} (A, B) &amp;=&amp; \;  Hom_{\mathcal{C}^{op}} (B, A) , \\
    \forall g          &amp; \in Hom_{\mathcal{C}} (B, C) &amp;=&amp; \;  Hom_{\mathcal{C}^{op}} (C, B) , \\
    \forall h          &amp; \in Hom_{\mathcal{C}} (C, D) &amp;=&amp; \;  Hom_{\mathcal{C}^{op}} (D, C) , \\
\end{aligned}\]</span> <span class="math display">\[\begin{aligned}
    h \star (g \star f) &amp;=&amp;  h \star (f  \circ g) \\
                        &amp;=&amp; (f \circ  g) \circ h  \\
                        &amp;=&amp;  f \circ  (g \circ h) \\
                        &amp;=&amp;  (g \circ h) \star f  \\
                        &amp;=&amp;  (h \star g) \star f  \\
\end{aligned}\]</span></p>
<p>Therefore, <span class="math inline">\(\star\)</span> is associative.</p>
<p>We conclude that <span class="math inline">\(\mathcal{C}^{op}\)</span> is a category.</p>
<h4 class="unnumbered" id="section-23">3.2)</h4>
<p>If <span class="math inline">\(A\)</span> is a finite set, how large is <span class="math inline">\(End_{\text{Set}}(A)\)</span> ?</p>
<p>We know that, in Set, <span class="math inline">\(End_{\text{Set}}(A) = (A \to A) = A^A\)</span>. From a previous exercise, we know that <span class="math inline">\(|B^A| = |B|^{|A|}\)</span>, therefore <span class="math inline">\(|End_{\text{Set}}(A)| = |A|^{|A|}\)</span>.</p>
<h4 class="unnumbered" id="section-24">3.3)</h4>
<p>Formulate precisely what it means to say that "<span class="math inline">\(1_a\)</span> is an identity with respect to composition" in Example 3.3, and prove this assertion.</p>
<p>Example 3.3 is that of a category over a set <span class="math inline">\(S\)</span> with a (reflexive, transitive) relation <span class="math inline">\(\sim\)</span>, where the objects of the category are the elements of <span class="math inline">\(S\)</span>, and the homset between two elements <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> is the singleton <span class="math inline">\((a,b)\)</span> if <span class="math inline">\(a \sim b\)</span>, and <span class="math inline">\(\emptyset\)</span> otherwise. Composition <span class="math inline">\(\circ\)</span> is given by transitivity of <span class="math inline">\(\sim\)</span>, where <span class="math inline">\((b,c) \circ (a,b) = (a,c)\)</span>. Reflexivity gives the identities (<span class="math inline">\(id_a = (a,a)\)</span> for any element <span class="math inline">\(a\)</span>).</p>
<p>In this context, to say that "<span class="math inline">\(1_a\)</span> is an identity with respect to composition" means that we can cancel out an element of the form <span class="math inline">\((a,a)\)</span> from a composition.</p>
<p>Formally, we have:</p>
<p><span class="math display">\[\forall a,b \in S, (b,b) \circ (a,b) = (a,b) = (a,b) \circ (a,a)\]</span></p>
<p>proving that <span class="math inline">\((b,b)\)</span> is indeed a post-identity, and <span class="math inline">\((a,a)\)</span> a pre-identity, in this context.</p>
<h4 class="unnumbered" id="section-25">3.4)</h4>
<p>Can we define a category in the style of Example 3.3, using the relation <span class="math inline">\(&lt;\)</span> on the set <span class="math inline">\(\mathbb{Z}\)</span> ?</p>
<p>(Description of example 3.3 in the exercise 3.3 just above.)</p>
<p>Naively, saying like in example 3.3 "there is a singleton homset <span class="math inline">\(\text{Hom}(a,b)\)</span> each time we have <span class="math inline">\(a &lt; b\)</span>", we cannot define such a category, since <span class="math inline">\(&lt;\)</span> is not reflexive, and we would thus lack identity morphisms.</p>
<p>However, in a roundabout way, we can define a category over the <em>negation</em> of <span class="math inline">\(&lt;\)</span>: "there is a singleton homset <span class="math inline">\(\text{Hom}(a,b)\)</span> each time we DO NOT have <span class="math inline">\(a &lt; b\)</span>". Namely this corresponds to the relation <span class="math inline">\(\ge\)</span>, which is, itself, reflexive, transitive (and antisymmetric), and is a valid instance of the kind of category presented in example 3.3.</p>
<p>In fact, the pair <span class="math inline">\((\mathbb{Z}, \geq)\)</span> is an instance of what is called a "totally ordered set", which is a more restrictive kind of "partially ordered set" (also called "poset" for short). Consequently, this kind of category is called a "poset category".</p>
<h4 class="unnumbered" id="section-26">3.5)</h4>
<p>Explain in what sense Example 3.4 is an instance of the categories considered in Example 3.3.</p>
<p>(Description of example 3.3 in the exercise 3.3 just above.)</p>
<p>Example 3.4 describes a category <span class="math inline">\(\hat{S}\)</span> where the objects are the subsets of a set <span class="math inline">\(S\)</span> (equivalently: elements of the powerset <span class="math inline">\(\mathcal{P}(S)\)</span> of <span class="math inline">\(S\)</span>), and morphisms between two subsets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> of <span class="math inline">\(S\)</span> are singleton (or empty) homsets based on whether the inclusion is true (or false).</p>
<p>Inclusion of sets, <span class="math inline">\(\subset\)</span>, is also an order relation, this time between the elements of a set of sets (here, <span class="math inline">\(\mathcal{P}(S)\)</span>). This means inclusion is reflexive, transitive, and antisymmetric. This makes <span class="math inline">\(\hat{S}\)</span> a poset category, and thus another instance of example 3.3.</p>
<h4 class="unnumbered" id="section-27">3.6)</h4>
<p>Define a category <span class="math inline">\(V\)</span> by taking <span class="math inline">\(Obj(V) = \mathbb{N}\)</span>, and <span class="math inline">\(Hom_V(n, m) = Mat_\mathbb{R}(m, n)\)</span>, the set of <span class="math inline">\(m \times n\)</span> matrices with real entries, for all <span class="math inline">\(n, m \in \mathbb{N}\)</span>. (I will leave the reader the task to make sense of a matrix with 0 rows or columns.) Use product of matrices to define composition. Does this category ’feel’ familiar ?</p>
<p>The formulation of the exercise is strange. It says to use the product of matrices to define composition, and to have homsets be sets of matrices, but objects of the category are supposed to be integers. I don’t know of any matrix with real entries that maps an integer to an integer in this way.</p>
<p>We thus infer that the meaning of the exercise can be one of two things.</p>
<p>Either we suppose the set of objects could rather be understood as "something isomorphic to <span class="math inline">\(\mathbb{N}\)</span>", ie, the collection of real vector spaces with finite bases (ie, <span class="math inline">\(\forall n \in \mathbb{N}, \mathbb{R}^n\)</span>). In which case, this is just the category of real vector spaces with finite basis (and linear maps as morphisms), which is a subcategory of the category real vector spaces (commonly called <span class="math inline">\(Vect_{\mathbb{R}}\)</span>). In this context, any morphism starting from <span class="math inline">\(0 \simeq \mathbb{R}^0 = \{0\}\)</span> is just the injection of the origin into the codomain; and any morphism ending at <span class="math inline">\(0\)</span> is the mapping of all elements to the origin.</p>
<p>Otherwise, we understand this as "yes, the objects of the category are integers: this means you should ignore the actual content of the matrices, and instead consider only their effect on the dimensionality of domains and codomains". In this case, this category is a complete directed graph over <span class="math inline">\(\mathbb{N}\)</span> where each edge corresponds to the change in dimension (from domain to codomain) caused by a given linear map.</p>
<h4 class="unnumbered" id="section-28">3.7)</h4>
<p>Define carefully objects and morphisms in Example 3.7, and draw the diagram corresponding to composition.</p>
<p>Example 3.7 (on coslice categories) refers to example 3.5 (on slice categories). Let’s go over slice categories (since example 3.5 asks the reader to "check all [their various properties]").</p>
<h5 class="unnumbered" id="slice-categories">3.7.1) Slice categories</h5>
<p>Slice categories are categories made by singling out an object (say <span class="math inline">\(A\)</span>) in some parent (larger) category (say <span class="math inline">\(\mathcal{C}\)</span>), and studying all morphisms into that object. These morphisms become the objects of a new category (ie, for any <span class="math inline">\(Z\)</span> of <span class="math inline">\(\mathcal{C}\)</span>, <span class="math inline">\(f \in (Z \to A)\)</span> is an object of the slice category, called <span class="math inline">\(\mathcal{C}_A\)</span> in this context). In the slice category, morphisms are defined as those morphism in <span class="math inline">\(\mathcal{C}\)</span> that preserve composition between 2 morphisms into <span class="math inline">\(A\)</span>.</p>
<p>Note that there exist pairs of morphisms <span class="math inline">\(f_1 \in (Z_1 \to A)\)</span> and <span class="math inline">\(f_2 \in (Z_2 \to A)\)</span> between which there is no morphism that exists in the slice category. One such example we can make is in <span class="math inline">\((Vect_\mathbb{R})_{\mathbb{R}^2}\)</span> (see notes "On the morphisms of slice and coslice categories" for more details).</p>
<p>3.7.1.a) Identity</p>
<p>A generic identity morphism is expressed diagrammatically in <span class="math inline">\(\mathcal{C}_A\)</span> as:</p>
<p>We can see that since <span class="math inline">\(f = f \circ id_Z\)</span> in <span class="math inline">\(\mathcal{C}\)</span>, this is compatible with the definition of a (pre-/right-)unit morphism in <span class="math inline">\(\mathcal{C}_A\)</span>. Also, since the only maps post-<span class="math inline">\(f\)</span> are maps from <span class="math inline">\(A \to A\)</span>, we have <span class="math inline">\(id_A\)</span> as the (post-/left-)unit for every morphism <span class="math inline">\(f\)</span> (ie, <span class="math inline">\(f = id_A \circ f\)</span>.</p>
<p>3.7.1.b) Composition</p>
<p>Taking 3 objects of the slice category (<span class="math inline">\(f_1 \in (Z_1 \to A)\)</span>, <span class="math inline">\(f_2 \in (Z_2 \to A)\)</span> and <span class="math inline">\(f_3 \in (Z_3 \to A)\)</span>), and two morphisms (<span class="math inline">\(\sigma_A\)</span> mapping <span class="math inline">\(f_1\)</span> to <span class="math inline">\(f_2\)</span> via a <span class="math inline">\(\mathcal{C}\)</span>-morphism <span class="math inline">\(\sigma \in (Z_1 \to Z_2)\)</span>, and <span class="math inline">\(\tau_A\)</span> mapping <span class="math inline">\(f_2\)</span> to <span class="math inline">\(f_3\)</span> via a <span class="math inline">\(\mathcal{C}\)</span>-morphism <span class="math inline">\(\tau \in (Z_2 \to Z_3)\)</span>), we have that <span class="math inline">\(f_1 = f_2 \circ \sigma\)</span> and <span class="math inline">\(f_2 = f_3 \circ \tau\)</span>. This is expressed as the following commutative diagram.</p>
<p>Composition of morphisms is then defined as <span class="math inline">\(\tau_A \circ_A \sigma_A\)</span> as a mapping from <span class="math inline">\(f_1\)</span> to <span class="math inline">\(f_3\)</span>, such that <span class="math inline">\(f_1 = f_3 \circ (\tau \circ \sigma)\)</span>. This can be understood through the following commutative diagram:</p>
<p>Which commutes, because we have:</p>
<p><span class="math display">\[\begin{aligned}
    f_1 &amp;=&amp;  f_2              \circ \sigma  \\
        &amp;=&amp; (f_3 \circ  \tau) \circ \sigma  \\
        &amp;=&amp;  f_3 \circ (\tau  \circ \sigma)
\end{aligned}\]</span></p>
<p>Thus, we have a working composition of morphisms.</p>
<p>3.7.1.c) Associativity</p>
<p>We take 4 objects of the slice category (<span class="math inline">\(f_1 \in (Z_1 \to A)\)</span>, <span class="math inline">\(f_2 \in (Z_2 \to A)\)</span>, <span class="math inline">\(f_3 \in (Z_3 \to A)\)</span> and <span class="math inline">\(f_4 \in (Z_4 \to A)\)</span>), and three morphisms (<span class="math inline">\(\sigma_A\)</span> mapping <span class="math inline">\(f_1\)</span> to <span class="math inline">\(f_2\)</span>, <span class="math inline">\(\tau_A\)</span> mapping <span class="math inline">\(f_2\)</span> to <span class="math inline">\(f_3\)</span>, and <span class="math inline">\(\upsilon_A\)</span> mapping <span class="math inline">\(f_3\)</span> to <span class="math inline">\(f_4\)</span>). Using composition defined as above, we have</p>
<p><span class="math display">\[\begin{aligned}
f_1 &amp;=&amp; f_4 \circ ( \upsilon \circ (\tau  \circ \sigma)) \\
    &amp;=&amp; f_4 \circ ((\upsilon \circ  \tau) \circ \sigma ) \\
\Rightarrow &amp;&amp; \\
&amp; &amp;  \upsilon_A \circ (\tau_A  \circ \sigma_A) \\
&amp;=&amp; (\upsilon_A \circ  \tau_A) \circ \sigma_A
\end{aligned}\]</span></p>
<p>Through associativity in <span class="math inline">\(\mathcal{C}\)</span>.</p>
<h5 class="unnumbered" id="coslice-categories">3.7.2) Coslice categories</h5>
<p>A coslice category <span class="math inline">\(\mathcal{C}^A\)</span> is similar, except it takes the morphisms coming <em>from</em> a chosen object <span class="math inline">\(A\)</span>, rather than those going <em>to</em> this object <span class="math inline">\(A\)</span>. Below is a commutative diagram in the style of the one of the textbook for slice categories.</p>
<p>We can similarly show that this also defines a category.</p>
<p><span class="underline">3.7.2.a) Identity</span></p>
<p>A generic identity morphism is expressed diagrammatically in <span class="math inline">\(\mathcal{C}^A\)</span> as:</p>
<p>We can see that since <span class="math inline">\(f = id_Z \circ f\)</span> in <span class="math inline">\(\mathcal{C}\)</span>, this is compatible with the definition of a (post-/left-)unit morphism in <span class="math inline">\(\mathcal{C}^A\)</span>. Also, since the only maps pre-<span class="math inline">\(f\)</span> are maps from <span class="math inline">\(A \to A\)</span>, we have <span class="math inline">\(id_A\)</span> as the (pre-/right-)unit for every morphism <span class="math inline">\(f\)</span> (ie, <span class="math inline">\(f = f \circ id_A\)</span>.</p>
<p><span class="underline">3.7.2.b) Composition</span></p>
<p>Taking 3 objects of the slice category (<span class="math inline">\(f_1 \in (A \to Z_1)\)</span>, <span class="math inline">\(f_2 \in (A \to Z_2)\)</span> and <span class="math inline">\(f_3 \in (A \to Z_3)\)</span>), and two morphisms (<span class="math inline">\(\sigma^A\)</span> mapping <span class="math inline">\(f_1\)</span> to <span class="math inline">\(f_2\)</span> via a <span class="math inline">\(\mathcal{C}\)</span>-morphism <span class="math inline">\(\sigma \in (Z_1 \to Z_2)\)</span>, and <span class="math inline">\(\tau^A\)</span> mapping <span class="math inline">\(f_2\)</span> to <span class="math inline">\(f_3\)</span> via a <span class="math inline">\(\mathcal{C}\)</span>-morphism <span class="math inline">\(\tau \in (Z_2 \to Z_3)\)</span>), we have that <span class="math inline">\(f_1 = \sigma \circ f_2\)</span> and <span class="math inline">\(f_2 = \tau  \circ f_3\)</span>. This is expressed as the following commutative diagram.</p>
<p>Composition of morphisms is then defined as <span class="math inline">\(\tau^A \circ^A \sigma^A\)</span> as a mapping from <span class="math inline">\(f_1\)</span> to <span class="math inline">\(f_3\)</span>, such that <span class="math inline">\(f_3 = (\tau \circ \sigma) \circ f_1\)</span>. This can be understood through the following commutative diagram:</p>
<p>Which commutes, because we have:</p>
<p><span class="math display">\[\begin{aligned}
    f_3 &amp;=&amp;  \tau \circ                f_2  \\
        &amp;=&amp;  \tau \circ (\sigma  \circ f_1) \\
        &amp;=&amp; (\tau \circ  \sigma) \circ f_1
\end{aligned}\]</span></p>
<p>Thus, we have a working composition of morphisms.</p>
<p><span class="underline">3.7.2.c) Associativity</span></p>
<p>We take 4 objects of the slice category (<span class="math inline">\(f_1 \in (A \to Z_1)\)</span>, <span class="math inline">\(f_2 \in (A \to Z_2)\)</span>, <span class="math inline">\(f_3 \in (A \to Z_3)\)</span> and <span class="math inline">\(f_4 \in (A \to Z_4)\)</span>), and three morphisms (<span class="math inline">\(\sigma^A\)</span> mapping <span class="math inline">\(f_1\)</span> to <span class="math inline">\(f_2\)</span>, <span class="math inline">\(\tau^A\)</span> mapping <span class="math inline">\(f_2\)</span> to <span class="math inline">\(f_3\)</span>, and <span class="math inline">\(\upsilon^A\)</span> mapping <span class="math inline">\(f_3\)</span> to <span class="math inline">\(f_4\)</span>). Using composition defined as above, we have</p>
<p><span class="math display">\[\begin{aligned}
f_4 &amp;=&amp; ( \upsilon \circ (\tau  \circ \sigma)) \circ f_1 \\
    &amp;=&amp; ((\upsilon \circ  \tau) \circ \sigma ) \circ f_1 \\
\Rightarrow &amp;&amp; \\
    &amp; &amp;  \upsilon^A \circ (\tau^A  \circ \sigma^A) \\
    &amp;=&amp; (\upsilon^A \circ  \tau^A) \circ \sigma^A
\end{aligned}\]</span></p>
<p>Through associativity in <span class="math inline">\(\mathcal{C}\)</span>.</p>
<h4 class="unnumbered" id="section-29">3.8)</h4>
<p>A subcategory <span class="math inline">\(\mathcal{C&#39;}\)</span> of a category <span class="math inline">\(\mathcal{C}\)</span> consists of a collection of objects of <span class="math inline">\(\mathcal{C}\)</span>, with morphisms <span class="math inline">\(Hom_\mathcal{C&#39;} (A, B) \subseteq Hom_\mathcal{C} (A, B)\)</span> for all objects <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> in <span class="math inline">\(Obj(\mathcal{C&#39;})\)</span>, such that identities and compositions in <span class="math inline">\(\mathcal{C}\)</span> make <span class="math inline">\(\mathcal{C&#39;}\)</span> into a category. A subcategory <span class="math inline">\(\mathcal{C&#39;}\)</span> is <em>full</em> if <span class="math inline">\(Hom_\mathcal{C&#39;} (A, B) = Hom_\mathcal{C} (A, B)\)</span> for all <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> in <span class="math inline">\(Obj(\mathcal{C&#39;})\)</span>. Construct a category of <em>infinite sets</em> and explain how it may be viewed as a full subcategory of <span class="math inline">\(\mathbf{Set}\)</span>.</p>
<p>To put it less technically, a "subcategory" <span class="math inline">\(\mathcal{C&#39;}\)</span> is just "picking only certain items of a base category <span class="math inline">\(\mathcal{C}\)</span>, and making sure that things stay closed uneder morphism composition". It is "full" if <em>all</em> morphisms between the objects that remain are also conserved.</p>
<p>We can construct a category <span class="math inline">\(\mathbf{InfSet}\)</span> of infinite sets by taking all the objects <span class="math inline">\(A\)</span> of <span class="math inline">\(\mathbf{Set}\)</span> such that <span class="math inline">\(\nexists n \in \mathbb{N}, |A| = n\)</span>, and only homsets between these objects. This is clearly a subcategory of <span class="math inline">\(\mathbf{Set}\)</span>, since it inherits all identity morphisms, composition works the same, and so does associativity; also, restricting the choice of homsets makes it so that the category is closed (you can’t reach a finite set via a homset that went from an infinite to a finite set).</p>
<p>For this category to not be full, there would need to be some homset that loses a morphism, or fully disappears, in the ordeal. However, there is no restriction as to the kind of morphism that is conserved, so any homset that is kept is identical to its original version. Finally, homsets between infinite sets are also infinite sets, so they don’t disappear in this operation.</p>
<p>Consequently <span class="math inline">\(\mathbf{InfSet}\)</span> defined as such is a full subcategory of <span class="math inline">\(\mathbf{Set}\)</span>.</p>
<h4 class="unnumbered" id="section-30">3.9)</h4>
<p>An alternative to the notion of multiset introduced in §2.2 is obtained by considering sets endowed with equivalence relations; equivalent elements are taken to be multiple instances of elements ’of the same kind’. Define a notion of morphism between such enhanced sets, obtaining a category <span class="math inline">\(\mathbf{MSet}\)</span> containing (a ’copy’ of) <span class="math inline">\(\mathbf{Set}\)</span> as a full subcategory. (There may be more than one reasonable way to do this! This is intentionally an open-ended exercise.) Which objects in <span class="math inline">\(\mathbf{MSet}\)</span> determine ordinary multisets as defined in §2.2, and how? Spell out what a morphism of multisets would be from this point of view. (There are several natural notions of morphisms of multisets. Try to define morphisms in MSet so that the notion you obtain for ordinary multisets captures your intuitive understanding of these objects.) [§2.2, §3.2, 4.5]</p>
<p>Let us recall how multisets were defined in §2.2. Since duplicate elements do not exist in sets, multisets were instead defined as functions from a set <span class="math inline">\(S\)</span> to <span class="math inline">\(\mathbb{N}*\)</span>, the set of (nonzero) positive integers. This allows each element in <span class="math inline">\(S\)</span> to have a "count", thereby encoding the intuitive notion of multiset. A similar, and equivalent (isomorphic), way of defining it is <em>via</em> pairs <span class="math inline">\((s, n) \in S \times \mathbb{N}*\)</span>, which is simpler to think about. We’ll call this category <span class="math inline">\(\mathbf{CMSet}\)</span>, for "count multiset" (TODO: probably has a conventional and better name, but I don’t know it). As for morphisms in <span class="math inline">\(\mathbf{CMSet}\)</span>, we can consider that for any multisets <span class="math inline">\(A = S_A \times \mathbb{N}*\)</span> and <span class="math inline">\(B = S_B \times \mathbb{N}*\)</span>, the homset from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span> is simply the set functions from <span class="math inline">\(S_A \times \mathbb{N}*\)</span> to <span class="math inline">\(S_B \times \mathbb{N}*\)</span> as usual.</p>
<p>We first notice that if we restrict <span class="math inline">\(\mathbf{CMSet}\)</span> to only the objects for which all elements have a count of <span class="math inline">\(1\)</span>, and where morphisms only ever output to <span class="math inline">\(\{ 1 \}\)</span> in the second coordinate (a subcategory we can call <span class="math inline">\(\mathbf{C1MSet}\)</span>, for example), we get a "copy" of <span class="math inline">\(\mathbf{Set}\)</span>: <span class="math inline">\(\mathbf{C1MSet}\)</span> and <span class="math inline">\(\mathbf{Set}\)</span> are isomorphic in <span class="math inline">\(\mathbf{Cat}\)</span>. This is a full subcategory because there are no morphisms that map counts to anything else than <span class="math inline">\(\{ 1 \}\)</span> if we restrict our objects to this form; so all morphisms between the kept objects are also kept.</p>
<p>Now let us do a similar construction, but based on equivalence classes instead. We know that each equivalence class over a set corresponds uniquely to a partition of that set. By considering only these partitions (these "sets of sets") as objects, we can build a category <span class="math inline">\(\mathbf{EMSet}\)</span> (for "equivalence multiset"). The "count" corresponds simply to the cardinal of a top-level element in the partition. For example, the top-level elements of <span class="math inline">\(M = \{ S_1, S_2, S_3 \}= \{ \{a\}, \{b, c\}, \{d, e, f\} \}\)</span> would be understood to have counts <span class="math inline">\(|S_1| = 1\)</span>, <span class="math inline">\(|S_2| = 2\)</span> and <span class="math inline">\(|S_3| = 3\)</span> respectively.</p>
<p>As for morphisms in <span class="math inline">\(\mathbf{EMSet}\)</span>, they simply map each top-level element of the domain multiset (a distinct subset of the original set) to some other top-level elements in the codomain multiset. This has precisely the same effect as mapping pairs of "value and count" as seen in the previous <span class="math inline">\(\mathbf{CMSet}\)</span> construction.</p>
<p>In this example, any set itself, when "injected" (by a functor) into <span class="math inline">\(\mathbf{EMSet}\)</span> would just nest all of its elements into singletons. I.e., <span class="math inline">\(S = \{ a, b, c \}\)</span> in <span class="math inline">\(\mathbf{Set}\)</span> would become <span class="math inline">\(S = \{ \{a\}, \{b\}, \{c\} \}\)</span> in <span class="math inline">\(\mathbf{EMSet}\)</span>. This also shows how restricting <span class="math inline">\(\mathbf{EMSet}\)</span> to "only objects that are a set of (toplevel) singletons" makes <span class="math inline">\(\mathbf{EMSet}\)</span> have a "copy" of <span class="math inline">\(\mathbf{Set}\)</span> as a full subcategory (for similar arguments as above).</p>
<p>Yet another example could be something akin to polynomials with integer coefficients on freeform indeterminates of degree 1 (which would be our set elements); raising the operators one rank, a product of freeform variables with integer powers (multiplicities), etc.</p>
<h4 class="unnumbered" id="section-31">3.10)</h4>
<p>Since the objects of a category <span class="math inline">\(\mathcal{C}\)</span> are not (necessarily) sets, it is not clear how to make sense of a notion of ’subobject’ in general. In some situations it does make sense to talk about subobjects, and the subobjects of any given object <span class="math inline">\(A\)</span> in <span class="math inline">\(\mathcal{C}\)</span> are in one-to-one correspondence with the morphisms <span class="math inline">\(A \to \Omega\)</span> for a fixed, special object <span class="math inline">\(\Omega\)</span> of <span class="math inline">\(\mathcal{C}\)</span>, called a subobject classifier. Show that <span class="math inline">\(\mathbf{Set}\)</span> has a subobject classifier.</p>
<p>We define the set <span class="math inline">\(\mathbb{B} = \{ 0, 1 \}\)</span>, aka the binary alphabet or booleans, as the subobject classifier of <span class="math inline">\(\mathbf{Set}\)</span>. For any subset <span class="math inline">\(A\)</span> of <span class="math inline">\(B\)</span>, there is a unique map <span class="math inline">\(f: B \to \mathbb{B}\)</span>, such that <span class="math inline">\(\forall b \in B, f(b) = 1 \Leftrightarrow b \in A\)</span> (otherwise <span class="math inline">\(f(b) = 0\)</span>, of course, as the equivalence and lack of alternatives to <span class="math inline">\(0\)</span> as an output imply). The map <span class="math inline">\(f\)</span> always fully describes <span class="math inline">\(A\)</span> from its relationship with <span class="math inline">\(B\)</span>.</p>
<h4 class="unnumbered" id="section-32">3.11)</h4>
<p>Draw the relevant diagrams and define composition and identities for the category <span class="math inline">\(\mathcal{C}^{A,B}\)</span> mentioned in Example 3.9. Do the same for the category <span class="math inline">\(\mathcal{C}^{\alpha, \beta}\)</span> mentioned in Example 3.10. [§5.5, 5.12]</p>
<p>For lack of a better term, we will refer to the categories of the form <span class="math inline">\(\mathcal{C}_{A,B}\)</span> represented by Example 3.9 as "bi-slice categories". The first part of the exercise is thus asking us to define and explain what "bi-coslice categories" (of the form <span class="math inline">\(\mathcal{C}^{A,B}\)</span>) are.</p>
<p>Similarly, we will refer to the categories of the form <span class="math inline">\(\mathcal{C}_{\alpha, \beta}\)</span> represented by Example 3.10 as "fibered bi-slice categories". The second part of the exercise is thus asking us to define and explain what "fibered bi-coslice categories" (of the form <span class="math inline">\(\mathcal{C}^{\alpha, \beta}\)</span>) are.</p>
<p>We will, of course, attempt to make more formal and pedagogical all definitions broached in the textbook’s examples as well.</p>
<h5 class="unnumbered" id="bi-slice-categories">3.11.1) Bi-slice categories</h5>
<p><span class="underline">3.11.1.a) Objects and morphisms</span></p>
<p>To make a bi-slice category <span class="math inline">\(\mathcal{C}_{A,B}\)</span>, we pick 2 objects <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> of a base category <span class="math inline">\(\mathcal{C}\)</span>, and consider for all other objects <span class="math inline">\(Z\)</span> of <span class="math inline">\(\mathcal{C}\)</span>, all pairs of morphisms <span class="math inline">\((f, g) \in (Z \to A) \times (Z \to B)\)</span>. These pairs of morphisms are the objects of the bi-slice category <span class="math inline">\(\mathcal{C}_{A,B}\)</span>. Morphisms <span class="math inline">\(\sigma_{A,B}\)</span> are defined from an object <span class="math inline">\(p_1 = (f_1, g_1) \in (Z_1 \to A) \times (Z_1 \to B)\)</span> to an object <span class="math inline">\(p_2 = (f_2, g_2) \in (Z_2 \to A) \times (Z_2 \to B)\)</span> so that we have both <span class="math inline">\(f_1 = f_2 \circ \sigma\)</span> and <span class="math inline">\(g_1 = g_2 \circ \sigma\)</span>, for some <span class="math inline">\(\sigma \in (Z_1 \to Z_2)\)</span>.</p>
<p>A generic object in <span class="math inline">\(\mathcal{C}_{A,B}\)</span> is of the form:</p>
<p><span class="underline">3.11.1.b) Morphisms</span></p>
<p>Morphisms are defined between objects as</p>
<p>such that the following diagram commutes</p>
<p><span class="underline">3.11.1.c) Identity</span></p>
<p>It is clear that identity morphisms exist for all objects, simply by taking <span class="math inline">\(Z = Z_1 = Z_2\)</span>, <span class="math inline">\(f_1 = f_2\)</span>, <span class="math inline">\(g_1 = g_2\)</span> and <span class="math inline">\(\sigma = id_Z\)</span>, in the diagram above.</p>
<p><span class="underline">3.11.1.d) Composition</span></p>
<p>Let be 3 objects of <span class="math inline">\(\mathcal{C}_{A,B}\)</span>, which we will name <span class="math inline">\(p_1\)</span>, <span class="math inline">\(p_2\)</span> and <span class="math inline">\(p_3\)</span> (and define with the respective <span class="math inline">\((Z_n, f_n, g_n)\)</span> triplet for <span class="math inline">\(p_n\)</span>).</p>
<p>Composition <span class="math inline">\(\tau_{A, B} \circ \sigma_{A, B} = p_1 \mapsto p_3\)</span> of two morphisms <span class="math inline">\(\sigma_{A, B} = p_1 \mapsto p_2\)</span> and <span class="math inline">\(\tau_{A, B} = p_2 \mapsto p_3\)</span> is defined so that the following diagram commutes.</p>
<p><span class="underline">3.11.1.e) Associativity</span></p>
<p>Associativity follows from associativity of morphisms in <span class="math inline">\(\mathcal{C}\)</span>, similarly to what was done for slice categories in exercise 3.7 .</p>
<h5 class="unnumbered" id="bi-coslice-categories">3.11.2) Bi-coslice categories</h5>
<p><span class="underline">3.11.2.a) Objects and morphisms</span></p>
<p>To make a bi-coslice category <span class="math inline">\(\mathcal{C}^{A,B}\)</span>, we similarly pick 2 objects <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> of our base category <span class="math inline">\(\mathcal{C}\)</span>, but instead consider, for all other objects <span class="math inline">\(Z\)</span> of <span class="math inline">\(\mathcal{C}\)</span>, all pairs of morphisms <span class="math inline">\((f, g) \in (A \to Z) \times (B \to Z)\)</span>.</p>
<p>A generic object in <span class="math inline">\(\mathcal{C}^{A,B}\)</span> is of the form:</p>
<p><span class="underline">3.11.2.b) Morphisms</span></p>
<p>Morphisms are defined between objects as</p>
<p>such that the following diagram commutes</p>
<p><span class="underline">3.11.2.c) Identity</span></p>
<p>It is clear that identity morphisms exist for all objects, simply by taking <span class="math inline">\(Z = Z_1 = Z_2\)</span>, <span class="math inline">\(f_1 = f_2\)</span>, <span class="math inline">\(g_1 = g_2\)</span> and <span class="math inline">\(\sigma = id_Z\)</span>, in the diagram above.</p>
<p><span class="underline">3.11.2.d) Composition</span></p>
<p>Let be 3 objects of <span class="math inline">\(\mathcal{C}^{A,B}\)</span>, which we will name <span class="math inline">\(p_1\)</span>, <span class="math inline">\(p_2\)</span> and <span class="math inline">\(p_3\)</span> (and define with the respective <span class="math inline">\((Z_n, f_n, g_n)\)</span> triplet for <span class="math inline">\(p_n\)</span>).</p>
<p>Composition <span class="math inline">\(\tau^{A, B} \circ \sigma^{A, B} = p_1 \mapsto p_3\)</span> of two morphisms <span class="math inline">\(\sigma^{A, B} = p_1 \mapsto p_2\)</span> and <span class="math inline">\(\tau^{A, B} = p_2 \mapsto p_3\)</span> is defined so that the following diagram commutes.</p>
<p><span class="underline">3.11.2.e) Associativity</span></p>
<p>Associativity follows from associativity of morphisms in <span class="math inline">\(\mathcal{C}\)</span>, similarly to what was done for slice categories in exercise 3.7 .</p>
<h5 class="unnumbered" id="fibered-bi-slice-categories">3.11.3) Fibered bi-slice categories</h5>
<p><span class="underline">3.11.3.a) Objects</span></p>
<p>To build a fibered bi-slice category <span class="math inline">\(\mathcal{C}_{\alpha, \beta}\)</span>, one takes a base category <span class="math inline">\(\mathcal{C}\)</span>, as well as a fixed pair of morphisms <span class="math inline">\(\alpha : A \to C\)</span> and <span class="math inline">\(\beta : B \to C\)</span> in <span class="math inline">\(\mathcal{C}\)</span>, that point to a common object <span class="math inline">\(C\)</span> of <span class="math inline">\(\mathcal{C}\)</span>. Our basic "fixed construct" from <span class="math inline">\(\mathcal{C}\)</span> looks like so:</p>
<p>The role of the category <span class="math inline">\(\mathcal{C}_{\alpha, \beta}\)</span> is now to study the morphisms into this construct. A generic object from this new category looks like so:</p>
<p>such that the diagram commutes. This means that valid object in <span class="math inline">\(\mathcal{C}_{\alpha, \beta}\)</span> are triplets <span class="math inline">\((Z, f, g)\)</span>, with <span class="math inline">\(f : Z \to A\)</span> and <span class="math inline">\(g : Z \to B\)</span>, such that <span class="math inline">\(\alpha \circ f = \beta \circ g\)</span>. In a caricatural way, this boils down to studying "the comparison of the different paths one can use to reach <span class="math inline">\(C\)</span>, knowing that the last steps are on one hand, <span class="math inline">\(\alpha\)</span>, and on the other, <span class="math inline">\(\beta\)</span>".</p>
<p><span class="underline">3.11.3.b) Morphisms</span></p>
<p>Morphisms are defined between objects as:</p>
<p>such that the following diagram commutes</p>
<p><span class="underline">3.11.3.c) Identity</span></p>
<p>Once again, it is clear that identity morphisms exist for all objects, simply by taking <span class="math inline">\(Z = Z_1 = Z_2\)</span>, <span class="math inline">\(f_1 = f_2\)</span>, <span class="math inline">\(g_1 = g_2\)</span> and <span class="math inline">\(\sigma = id_Z\)</span>, in the diagram above.</p>
<p><span class="underline">3.11.3.d) Composition</span></p>
<p>Let be 3 objects of <span class="math inline">\(\mathcal{C}_{\alpha, \beta}\)</span>, which we will name <span class="math inline">\(p_1\)</span>, <span class="math inline">\(p_2\)</span> and <span class="math inline">\(p_3\)</span> (and define with the respective <span class="math inline">\((Z_n, f_n, g_n)\)</span> triplet for <span class="math inline">\(p_n\)</span>).</p>
<p>Composition <span class="math inline">\(\tau_{\alpha, \beta} \circ \sigma_{\alpha, \beta} = p_1 \mapsto p_3\)</span> of two morphisms <span class="math inline">\(\sigma_{\alpha, \beta} = p_1 \mapsto p_2\)</span> and <span class="math inline">\(\tau_{\alpha, \beta} = p_2 \mapsto p_3\)</span> is defined so that the following diagram commutes.</p>
<p><span class="underline">3.11.3.e) Associativity</span></p>
<p>Associativity follows from associativity of morphisms in <span class="math inline">\(\mathcal{C}\)</span>, similarly to what was done for slice categories in exercise 3.7 .</p>
<h5 class="unnumbered" id="fibered-bi-coslice-categories">3.11.4) Fibered bi-coslice categories</h5>
<p><span class="underline">3.11.4.a) Objects</span></p>
<p>To build a fibered bi-coslice category <span class="math inline">\(\mathcal{C}^{\alpha, \beta}\)</span>, one takes a base category <span class="math inline">\(\mathcal{C}\)</span>, as well as a fixed pair of morphisms <span class="math inline">\(\alpha : C \to A\)</span> and <span class="math inline">\(\beta : C \to B\)</span> in <span class="math inline">\(\mathcal{C}\)</span>, that originate from a common object <span class="math inline">\(C\)</span> of <span class="math inline">\(\mathcal{C}\)</span>. Our basic "fixed construct" from <span class="math inline">\(\mathcal{C}\)</span> looks like so:</p>
<p>The role of the category <span class="math inline">\(\mathcal{C}^{\alpha, \beta}\)</span> is now to study the morphisms from this construct. A generic object from this new category looks like so:</p>
<p>such that the diagram commutes. This means that valid object in <span class="math inline">\(\mathcal{C}^{\alpha, \beta}\)</span> are triplets <span class="math inline">\((Z, f, g)\)</span>, with <span class="math inline">\(f : A \to Z\)</span> and <span class="math inline">\(g : B \to Z\)</span>, such that <span class="math inline">\(f \circ \alpha = g \circ \beta\)</span>. In a caricatural way, this boils down to studying "the comparison of the different paths one can build by starting from <span class="math inline">\(C\)</span>, knowing that the choice of first step is on one hand, <span class="math inline">\(\alpha\)</span>, and on the other, <span class="math inline">\(\beta\)</span>".</p>
<p><span class="underline">3.11.4.b) Morphisms</span></p>
<p>Morphisms are defined between objects as:</p>
<p>such that the following diagram commutes</p>
<p><span class="underline">3.11.4.c) Identity</span></p>
<p>Once again, it is clear that identity morphisms exist for all objects, simply by taking <span class="math inline">\(Z = Z_1 = Z_2\)</span>, <span class="math inline">\(f_1 = f_2\)</span>, <span class="math inline">\(g_1 = g_2\)</span> and <span class="math inline">\(\sigma = id_Z\)</span>, in the diagram above.</p>
<p><span class="underline">3.11.4.d) Composition</span></p>
<p>Let be 3 objects of <span class="math inline">\(\mathcal{C}^{\alpha, \beta}\)</span>, which we will name <span class="math inline">\(p_1\)</span>, <span class="math inline">\(p_2\)</span> and <span class="math inline">\(p_3\)</span> (and define with the respective <span class="math inline">\((Z_n, f_n, g_n)\)</span> triplet for <span class="math inline">\(p_n\)</span>).</p>
<p>Composition <span class="math inline">\(\tau^{\alpha, \beta} \circ \sigma^{\alpha, \beta} = p_1 \mapsto p_3\)</span> of two morphisms <span class="math inline">\(\sigma^{\alpha, \beta} = p_1 \mapsto p_2\)</span> and <span class="math inline">\(\tau^{\alpha, \beta} = p_2 \mapsto p_3\)</span> is defined so that the following diagram commutes.</p>
<p><span class="underline">3.11.4.e) Associativity</span></p>
<p>Associativity follows from associativity of morphisms in <span class="math inline">\(\mathcal{C}\)</span>, similarly to what was done for slice categories in exercise 3.7 .</p>
<h3 class="unnumbered" id="section-4-1">Section 4)</h3>
<h4 class="unnumbered" id="section-33">4.1)</h4>
<p>Composition is defined for <em>two</em> morphisms. If more than 2 morphisms are given, one may compose them in several ways, so that every step only consists in composing 2 morphisms. Prove that for any such valid sequence of morphisms, the order of parentheses doesn’t matter.</p>
<p>This boils down to showing that associativity is a global property, that doesn’t just make parentheses meaningless when there are 3 elements and 2 operators between them, but in general <span class="math inline">\(n\)</span> elements with <span class="math inline">\((n-1)\)</span> operators between them.</p>
<p>Note: A useful way of visualizing this is representing the order of operations as a binary tree, and noticing that applying associativity (forwards or backwards) is just a tree rotation (resp. right or left) at a given node. Then it is easy to show that one can always obtain a "left comb binary tree". Since every choice of parentheses is equal to this left comb choice, and equality is transitive, every choice of parentheses is equal to every other choice.</p>
<p>To be more rigorous, we will proceed by induction.</p>
<p><span class="underline">Hypothesis:</span> <span class="math inline">\(P(n)\)</span> = "for a given <span class="math inline">\(n\)</span>, for <span class="math inline">\(f_n f_{n-1} \cdot f_1\)</span> any valid, composable, ordered sequence of morphisms in our base category <span class="math inline">\(\mathcal{C}\)</span>, any choice <span class="math inline">\(H\)</span> of parentheses to compose elements of this sequence 2-by-2, giving a formula <span class="math inline">\(s_H\)</span>, will lead to the same result, which can be seen by always having <span class="math inline">\(s_H = (\cdot(f_n f_{n-1}) \cdot) f_1\)</span>".</p>
<p><span class="underline">Initialization:</span> We initialize at <span class="math inline">\(n = 3\)</span>; the validity is immediate as it is precisely the definition of associativity.</p>
<p><span class="underline">Heredity:</span> We suppose the hypothesis <span class="math inline">\(P(n)\)</span> true for a given <span class="math inline">\(n \geq 3\)</span>; let us show that this implies that the hypothesis is true for <span class="math inline">\(P(n+1)\)</span>.</p>
<p>What this means is that, no matter the composable ordered sequence <span class="math inline">\(f_n f_{n-1} \cdot f_1\)</span> of <span class="math inline">\(n\)</span> functions, for a fixed <span class="math inline">\(n\)</span>, the order of parentheses does not matter. Note that though <span class="math inline">\(n\)</span> is chosen and fixed; the statement is true for EVERY (ordered, composable) sequence of functions. We add a new function <span class="math inline">\(g\)</span> to this sequence. By a simple renaming of the functions, we deduce that it doesn’t matter where we insert <span class="math inline">\(g\)</span>, so we’ll insert it at the very right to simplify our argument, giving us the sequence <span class="math inline">\(f_n f_{n-1} \cdot f_1 g\)</span>.</p>
<p>Here, there are 3 cases. Either:</p>
<ul>
<li><p><span class="math inline">\(g\)</span> is part of the last composition (i.e., it’s not in a semantically necessary parenthethical grouping; it can be made external to all parentheses),</p></li>
<li><p><span class="math inline">\(g\)</span> is part of the first composition (i.e., the first operation is <span class="math inline">\((f_1 g)\)</span>)</p></li>
<li><p>it isn’t either (it’s inside some non-removable parentheses, and needs to be composed earlier on, but not as the first operation).</p></li>
</ul>
<p>If <span class="math inline">\(g\)</span> is part of the last composition, then by applying the hypothesis <span class="math inline">\(P(n)\)</span> to the terms <span class="math inline">\(f_n f_{n-1} \cdot f_1\)</span>, we immediately find that our new sequence can be made equal to <span class="math inline">\(((\cdot(f_n f_{n-1}) \cdot) f_1) g\)</span>, which is precisely what we wanted for <span class="math inline">\(P(n+1)\)</span>.</p>
<p>If <span class="math inline">\(g\)</span> is part of the first composition, we isolate it so that it isn’t anymore. To do so, we apply "backwards" associativity on the grouping of terms <span class="math inline">\(F_k (f_1 g)\)</span> in order to obtain <span class="math inline">\((F_k f_1) g\)</span>, where <span class="math inline">\(F_k\)</span> is the appropriate choice of <span class="math inline">\((f_k \cdot f_2)\)</span> such that associativity can be applied (with <span class="math inline">\(2 \leq k \leq n\)</span>). This makes it so that our problem is identical to our final case, solved just below.</p>
<p>If <span class="math inline">\(g\)</span> is part of neither the first nor last composition, then we consider the innermost composition <span class="math inline">\((f_k f_{k-1})\)</span> to be a single element <span class="math inline">\(h\)</span>. We now have a sequence of only <span class="math inline">\(n\)</span> terms. We apply our hypothesis <span class="math inline">\(P(n)\)</span>. This makes <span class="math inline">\(g\)</span> the outermost right term, part of the last composition. Unravelling <span class="math inline">\(h\)</span> back into two members, we see that we are back at our initial case, with an arbitrary order of parentheses for the <span class="math inline">\(f_n f_{n-1} \cdot f_1\)</span> terms, and <span class="math inline">\(g\)</span> outermost. We already saw that this implied <span class="math inline">\(P(n+1)\)</span>.</p>
<p><span class="underline">Conclusion:</span> since we have initialization and heredity of our hypothesis in all cases, we can conclude by induction that it is true for all <span class="math inline">\(n \geq 3\)</span>.</p>
<h4 class="unnumbered" id="section-34">4.2)</h4>
<p>In Example 3.3 we have seen how to construct a category from a set endowed with a relation, provided the latter is reflexive and transitive. For what types of relations is the corresponding category a groupoid (cf. Example 4.6) ?</p>
<p>We remind example 4.6 : a groupoid is a category in which every morphism is an isomorphism. This means that every morphism needs to be 2-way invertible.</p>
<p>In this context, this means that for every morphism <span class="math inline">\(a \sim b\)</span>, there should be a corresponding inverse morphism <span class="math inline">\(b \sim a\)</span>. This property is precisely the symmetry of a relation.</p>
<p>This means that all sets with an equivalence relation can be reconstructed into a groupoid.</p>
<h4 class="unnumbered" id="section-35">4.3)</h4>
<p>Let <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> be objects of a category <span class="math inline">\(\mathcal{C}\)</span>, and <span class="math inline">\(f \in Hom_{\mathcal{C}} (A, B)\)</span> a morphism. Prove that if <span class="math inline">\(f\)</span> has a pre-inverse, then <span class="math inline">\(f\)</span> is an epimorphism. Show that the converse does not hold, by giving an explicit example of a category and an epimorphism without a pre-inverse.</p>
<h5 class="unnumbered" id="a-1">4.3.a)</h5>
<p><span class="math inline">\(f\)</span> has a pre-inverse <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(f\)</span> is an epimorphism</p>
<p>Let <span class="math inline">\(\mathcal{C}\)</span> be a category. Let <span class="math inline">\(f \in Hom_{\mathcal{C}} (A, B)\)</span>, having some pre-inverse which we’ll call <span class="math inline">\(g \in Hom_{\mathcal{C}} (B, A)\)</span>:</p>
<p>Let <span class="math inline">\(Z\)</span> be an arbitrary object of <span class="math inline">\(\mathcal{C}\)</span>, and <span class="math inline">\(\beta&#39;, \beta&quot; \in Hom_{\mathcal{C}} (B, Z)\)</span>:</p>
<p><span class="math display">\[\begin{aligned}
    \beta&#39; \circ f = \beta&#39;&#39; \circ f
        &amp; \Rightarrow (\beta&#39; \circ  f) \circ g  = (\beta&#39;&#39; \circ  f) \circ g  \\
        &amp; =            \beta&#39; \circ (f  \circ g) =  \beta&#39;&#39; \circ (f  \circ g) \\
        &amp; =            \beta&#39; \circ id_B         =  \beta&#39;&#39; \circ id_B \\
        &amp; =            \beta&#39;                    =  \beta&#39;&#39;
\end{aligned}\]</span></p>
<p>This means that <span class="math inline">\(f\)</span> is an epimorphism.</p>
<h5 class="unnumbered" id="b-1">4.3.b)</h5>
<p><span class="math inline">\(f\)</span> is an epimorphism <span class="math inline">\(\;\not\!\!\!\Rightarrow\)</span> <span class="math inline">\(f\)</span> has a pre-inverse</p>
<p>As was mentioned in the text, "order" categories (poset categories) where there’s only at most one morphism between any two objects makes it so that every morphism is trivially an epimorphism. However, only identities have any kind of inverse (since they are isomorphisms, they are their own inverse).</p>
<p>See also <a href="https://ncatlab.org/nlab/show/partial+order">here</a> and <a href="https://math.stackexchange.com/questions/81123/examples-of-categories-where-epimorphism-does-not-have-a-right-inverse-not-surj">here</a>.</p>
<h4 class="unnumbered" id="section-36">4.4)</h4>
<p>Prove that the composition of two monomorphisms is a monomorphism. Deduce that one can define a subcategory <span class="math inline">\(\mathcal{C}_{mono}\)</span> of a category <span class="math inline">\(\mathcal{C}\)</span> by taking the same objects as in <span class="math inline">\(\mathcal{C}\)</span>, and defining <span class="math inline">\(Hom_{\mathcal{C}_{mono}} (A, B)\)</span> to be the subset of <span class="math inline">\(Hom_\mathcal{C} (A, B)\)</span> consisting of monomorphisms, for all objects <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>. (Cf. Exercise 3.8; of course, in general <span class="math inline">\(\mathcal{C}_{mono}\)</span> is not full in <span class="math inline">\(\mathcal{C}\)</span>.) Do the same for epimorphisms. Can you define a subcategory <span class="math inline">\(\mathcal{C}_{nonmono}\)</span> of <span class="math inline">\(\mathcal{C}\)</span> by restricting to morphisms that are not monomorphisms?</p>
<h5 class="unnumbered" id="a-2">4.4.a)</h5>
<p>Mono</p>
<p>Let be <span class="math inline">\(f \in Hom_{\mathcal{C}} (A, B)\)</span> and <span class="math inline">\(g \in Hom_{\mathcal{C}} (B, C)\)</span> be monomorphisms. Let us show that <span class="math inline">\(g \circ f\)</span> is also a monomorphism.</p>
<p>Let <span class="math inline">\(Z\)</span> be an arbitrary object of <span class="math inline">\(\mathcal{C}\)</span>, and <span class="math inline">\(\alpha&#39;, \alpha&quot; \in Hom_{\mathcal{A}} (Z, A)\)</span>:</p>
<p><span class="math display">\[\begin{aligned}
    (g \circ f) \circ \alpha&#39; = (g \circ f) \circ \alpha&#39;&#39;
        &amp; = g \circ (f \circ \alpha&#39;) = g \circ (f \circ \alpha&#39;&#39;) \\
        &amp; \Rightarrow f \circ \alpha&#39; = f \circ \alpha&#39;&#39; \text{ because $g$ is mono} \\
        &amp; \Rightarrow         \alpha&#39; =         \alpha&#39;&#39; \text{ because $f$ is mono}
\end{aligned}\]</span></p>
<p>This means that the composition of 2 monomorphisms is always an monomorphism. We can thus make a subcategory. Taking all objects, properties, and homsets of <span class="math inline">\(\mathcal{C}\)</span>, but restricting the homsets only to the monomorphisms, we know that this makes a new category <span class="math inline">\(\mathcal{C}_{mono}\)</span> since it is closed under composition, has identities (which are iso, and <em>a fortiori</em> mono) and associativity.</p>
<h5 class="unnumbered" id="b-2">4.4.b)</h5>
<p>Epi</p>
<p>Let be <span class="math inline">\(f \in Hom_{\mathcal{C}} (A, B)\)</span> and <span class="math inline">\(g \in Hom_{\mathcal{C}} (B, C)\)</span> be epimorphisms. Let us show that <span class="math inline">\(g \circ f\)</span> is also a epimorphism.</p>
<p>Let <span class="math inline">\(Z\)</span> be an arbitrary object of <span class="math inline">\(\mathcal{C}\)</span>, and <span class="math inline">\(\beta&#39;, \beta&quot; \in Hom_{\mathcal{C}} (C, Z)\)</span>:</p>
<p><span class="math display">\[\begin{aligned}
    \beta&#39; \circ (g \circ f) = \beta&#39;&#39; \circ (g \circ f)
        &amp; = (\beta&#39; \circ g) \circ f = (\beta&#39;&#39; \circ g) \circ f \\
        &amp; \Rightarrow \beta&#39; \circ g =  \beta&#39;&#39; \circ g \text{ because $f$ is epi} \\
        &amp; \Rightarrow \beta&#39;         =  \beta&#39;&#39;         \text{ because $g$ is epi}
\end{aligned}\]</span></p>
<p>This means that the composition of 2 epimorphisms is always an epimorphism. We can thus make a subcategory. Taking all objects, properties, and homsets of <span class="math inline">\(\mathcal{C}\)</span>, but restricting the homsets only to the epimorphisms, we know that this makes a new category <span class="math inline">\(\mathcal{C}_{epi}\)</span> since it is closed under composition, has identities (which are iso, and <em>a fortiori</em> epi) and associativity.</p>
<h5 class="unnumbered" id="c">4.4.c)</h5>
<p>Nonmono and nonepi</p>
<p>We could consider the fact that (TODO prove lol) we can’t obtain a monomorphism from the composition of two non-monomorphisms (you need at least one monomorphism in the mix). However, the real problem is identities. Identities are iso, and thus mono. You can’t make a category without identities, so there is no such <span class="math inline">\(\mathcal{C}_{nonmono}\)</span>. the same reasoning applies to <span class="math inline">\(\mathcal{C}_{nonepi}\)</span>.</p>
<h4 class="unnumbered" id="section-37">4.5)</h4>
<p>Give a concrete description of monomorphisms and epimorphisms in the category <span class="math inline">\(\mathbf{MSet}\)</span> you constructed in Exercise 3.9. (Your answer will depend on the notion of morphism you defined in that exercise!)</p>
<p>We’ll use our <span class="math inline">\(\mathbf{CMSet}\)</span> construction, where elements of multisets consisted of a pair of the set-element and its count in the multiset.</p>
<p>We recall that in the way we formulated this, morphisms were just simple set functions on "(element, count)" pairs (i.e., returning any other "(element, count)" pair of the codomain). Let be a morphism of multisets <span class="math inline">\(f \in (A \to B)\)</span>. Labelling the elements of the domain <span class="math inline">\(A\)</span> as <span class="math inline">\(a_i\)</span> and of the codomain <span class="math inline">\(B\)</span> as <span class="math inline">\(b_j\)</span> with <span class="math inline">\(i \in I\)</span>, <span class="math inline">\(j \in J\)</span>, and <span class="math inline">\(I, J\)</span> any two indexing sets such that <span class="math inline">\(card(A) = card(I)\)</span> and <span class="math inline">\(card(B) = card(J)\)</span>, we can see that <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> now just look like "normal" sets.</p>
<p>We now simply recycle the notion of injections and surjections. These form our monomorphisms and epimorphisms respectively.</p>
<h3 class="unnumbered" id="section-5-1">Section 5)</h3>
<h4 class="unnumbered" id="section-38">5.1)</h4>
<p>Prove that a final object in a category <span class="math inline">\(\mathcal{C}\)</span> is initial in the opposite category <span class="math inline">\(\mathcal{C}^{op}\)</span></p>
<p>Let <span class="math inline">\(\mathcal{C}\)</span> be a category. Let <span class="math inline">\(\mathcal{C}^{op}\)</span> be the dual category on <span class="math inline">\(\mathcal{C}\)</span>. Let <span class="math inline">\(F\)</span> be a final object in <span class="math inline">\(\mathcal{C}\)</span>. This means that for every object <span class="math inline">\(Z\)</span> in <span class="math inline">\(\mathcal{C}\)</span>, there is a single morphism from <span class="math inline">\(Z\)</span> to <span class="math inline">\(F\)</span>. We will call this morphism <span class="math inline">\(f_Z\)</span> (respectively).</p>
<p>We remind how we defined composition in <span class="math inline">\(\mathcal{C}^{op}\)</span> as <span class="math inline">\(\star\)</span>, respecting: <span class="math display">\[\begin{aligned}
    &amp; \forall f \in Hom_{\mathcal{C}^{op}} (B, A) = Hom_{\mathcal{C}} (A, B), \\
    &amp; \forall g \in Hom_{\mathcal{C}^{op}} (C, B) = Hom_{\mathcal{C}} (B, C), \\
    &amp; \exists h \in Hom_{\mathcal{C}^{op}} (C, A) = Hom_{\mathcal{C}} (A, C), \\
    &amp; f \star g \coloneqq g \circ f = h
\end{aligned}\]</span></p>
<p>In this case, we see that <span class="math inline">\(\forall Z \in Obj(\mathcal{C}^{op}) = Obj(\mathcal{C}), f_Z \in Hom_{\mathcal{C}^{op}} (F, Z) = Hom_{\mathcal{C}} (Z, F)\)</span>. This implies that the homset <span class="math inline">\(Hom_{\mathcal{C}^{op}} (F, Z)\)</span> contains a single morphism, <span class="math inline">\(f_Z\)</span>. This means that <span class="math inline">\(F\)</span> is initial in <span class="math inline">\(mathcal{C}^{op}\)</span>.</p>
<h4 class="unnumbered" id="section-39">5.2)</h4>
<p>Prove that <span class="math inline">\(\emptyset\)</span> is the <em>unique</em> initial object in <strong>Set</strong>.</p>
<p>First we will prove that it is initial, then that it is unique.</p>
<p>Initiality: we take an arbitrary set <span class="math inline">\(Z\)</span> in <strong>Set</strong>. We wish to study <span class="math inline">\(Hom_{\text{\textbf{Set}}}(\emptyset, Z) = Z^\emptyset\)</span>. We recall that functions (in category theory) are defined as "applications" / "mappings" are in traditional set theory (i.e., as a relation between sets where every antecedent in the domain has a singleton image in the codomain; the key point being that "no input has no result when passed through the function"). Let <span class="math inline">\(I\)</span> be an initial element in <strong>Set</strong>. We write <span class="math inline">\(|I| = n\)</span> and <span class="math inline">\(|Z| = m\)</span>. We know that <span class="math inline">\(|Z^I| = |Z|^{|I|} = m^n\)</span>. For <span class="math inline">\(I\)</span> to be initial, this is true if and only if <span class="math inline">\(m^n = 1\)</span> for all <span class="math inline">\(m\)</span>, and so if and only if <span class="math inline">\(n = 0\)</span>. We recall that the empty set is the only set with <span class="math inline">\(|\emptyset| = 0\)</span>, therefore <span class="math inline">\(I = \emptyset\)</span>.</p>
<p>Now this is already enough to prove unicity, but let us spell it out for pedagogy’s sake.</p>
<p>Unicity: We recall that two objects of <strong>Set</strong> are isomorphic if, and only if, there exists a bijection between them. This is equivalent to saying that two sets have the same cardinal. We once again recall that the empty set is the only set with <span class="math inline">\(|\emptyset| = 0\)</span>; there are no bijections relating to the empty set, other than its identity, the unique morphism in <span class="math inline">\(Hom_{\text{\textbf{Set}}}(\emptyset, \emptyset)\)</span> . Using proposition 5.4 (that terminal objects are unique up-to-isomorphism), we finally deduce that <span class="math inline">\(\emptyset\)</span> is the unique initial object in <strong>Set</strong>.</p>
<p>NB: the unique function in <span class="math inline">\(Z^\emptyset\)</span> is always the empty function.</p>
<h4 class="unnumbered" id="section-40">5.3)</h4>
<p>Prove that final objects are unique up to isomorphism.</p>
<p>Let us suppose we have a category <span class="math inline">\(\mathcal{C}\)</span> with two final objects, <span class="math inline">\(F_1\)</span> and <span class="math inline">\(F_2\)</span>.</p>
<p>For every object <span class="math inline">\(A\)</span> of <span class="math inline">\(\mathcal{C}\)</span> there is at least one element in <span class="math inline">\(Hom_{\mathcal{C}} (A, A)\)</span>, namely the identity <span class="math inline">\(1_A\)</span>. If <span class="math inline">\(F\)</span> is final, then there is a unique morphism <span class="math inline">\(F \to F\)</span>, which therefore must be the identity <span class="math inline">\(1_F\)</span>.</p>
<p>Now assume <span class="math inline">\(F_1\)</span> and <span class="math inline">\(F_2\)</span> are both final in <span class="math inline">\(\mathcal{C}\)</span>. Since <span class="math inline">\(F_1\)</span> is final, there is a unique morphism <span class="math inline">\(f : F_2 \to F_1\)</span> in <span class="math inline">\(\mathcal{C}\)</span>. Since <span class="math inline">\(F_2\)</span> is final, there is a unique morphism <span class="math inline">\(g : F_1 \to F_2\)</span> in <span class="math inline">\(\mathcal{C}\)</span>. Consider <span class="math inline">\(gf : F_1 \to F_1\)</span> ; as observed, necessarily <span class="math inline">\(gf = 1_{F_2}\)</span> since <span class="math inline">\(F_1\)</span> is final. By the same token <span class="math inline">\(fg = 1{F_1}\)</span>, proving <span class="math inline">\(f\)</span> is an isomorphism. Thus <span class="math inline">\(F_1 \simeq F_2\)</span>.</p>
<h4 class="unnumbered" id="section-41">5.4)</h4>
<p>What are initial and final objects in the category of "pointed sets" (Example 3.8)? Are they unique?</p>
<p>We recall that a pointed set is just a regular set with a special, identified point, and that the category of pointed sets <strong>Set*</strong> is built upon the same objects as <strong>Set</strong>, but where each object <span class="math inline">\(A\)</span> in <strong>Set</strong> is multiplied into <span class="math inline">\(|A|\)</span> copies of itself in <strong>Set*</strong> (one for each choice of special point; this implies that the empty set is not a part of <strong>Set*</strong>, since it has no point). Morphisms in <strong>Set*</strong> are set functions, but with the restriction of mapping the special point in the domain to the special point in the codomain.</p>
<p>Given this information, we will prove that the initial and final objects in <strong>Set*</strong> are the singleton sets.</p>
<p>Let <span class="math inline">\((O, o)\)</span> be a singleton set in <strong>Set*</strong>. Let <span class="math inline">\(o\)</span> be the single element of <span class="math inline">\(O\)</span>; it is necessarily also the special point, as there is no other choice. For any codomain <span class="math inline">\((Z, z_0)\)</span> in <strong>Set*</strong>, the condition that "special points map to special points" restricts our choice of function to the unique function <span class="math inline">\({(o, z_0)}\)</span>, thus, <span class="math inline">\(O\)</span> is initial. If <span class="math inline">\(O\)</span> had more than one element, there would exist some <span class="math inline">\(Z\)</span> (non-singletons) for which the other element would allow another degree of freedom (and thus <span class="math inline">\(O\)</span> would not be initial).</p>
<p>Similarly, now studying <span class="math inline">\(Z\)</span> as a domain and <span class="math inline">\(O\)</span> as a codomain, we see that that only function from <span class="math inline">\(Z\)</span> to <span class="math inline">\(O\)</span> is (like in <strong>Set</strong>) the function which maps everything (including <span class="math inline">\(Z\)</span>’s special point) to <span class="math inline">\(o\)</span>. Thus, <span class="math inline">\(O\)</span> is final. If <span class="math inline">\(O\)</span> had more than one element, there would similarly be many choices for any <span class="math inline">\(Z\)</span> of cardinal <span class="math inline">\(\geq 2\)</span>, so long as the special point maps to the special point.</p>
<p>Every singleton pointed set is both initial and final in <strong>Set*</strong> and is thus a zero object. These are also the only such pointed sets.</p>
<h4 class="unnumbered" id="section-42">5.5)</h4>
<p>What are the final objects in the category considered in §5.3?</p>
<p>The category considered in paragraph 5.3 is the coslice category over some set <span class="math inline">\(A\)</span>. However, what is presented in this paragraph is some extra structure that arises when considering the statement "The quotient <span class="math inline">\(A/\sim\)</span> is universal with respect to the property of mapping <span class="math inline">\(A\)</span> to a set in such a way that equivalent elements have the same image". We thus give some equivalence relation <span class="math inline">\(\sim\)</span> on <span class="math inline">\(A\)</span> and study the quotient set <span class="math inline">\(A/\sim\)</span> in the general coslice category; to do this, we consider the subcategory <span class="math inline">\(\mathcal{Q}\)</span> of <span class="math inline">\(\mathcal{C}_A\)</span> where only <span class="math inline">\(\varphi\)</span> such that "equivalence is preserved" (i.e., such that <span class="math inline">\(\forall a&#39;, a&#39;&#39; \in A, a&#39; \sim a&#39;&#39; \Rightarrow \varphi(a&#39;) = \varphi(a&#39;&#39;)\)</span>).</p>
<p>With:</p>
<ul>
<li><p><span class="math inline">\(s\)</span> the canonical surjection of <span class="math inline">\(A\)</span> onto its quotient <span class="math inline">\(A/\sim\)</span>,</p></li>
<li><p><span class="math inline">\(\varphi_1\)</span> (resp. <span class="math inline">\(\varphi_2\)</span>) being some arbitrary function from <span class="math inline">\(A\)</span> to some arbitrary <span class="math inline">\(Z_1\)</span> (resp. <span class="math inline">\(Z_2\)</span>),</p></li>
<li><p><span class="math inline">\(\sigma\)</span> any function (if it exists) such that <span class="math inline">\(\sigma \varphi_1 = \varphi_2\)</span></p></li>
<li><p><span class="math inline">\(f_1\)</span> (resp. <span class="math inline">\(f_2\)</span>) is the (unique!) function such that <span class="math inline">\(s f_1 = \varphi_1\)</span> (resp. <span class="math inline">\(s f_2 = \varphi_2\)</span>)</p></li>
</ul>
<p>The following diagram commutes, and summarizes the situation.</p>
<p>Objects in this category are denoted as <span class="math inline">\((\varphi, Z)\)</span> and are obtained from what used to be <em>morphisms</em> (regular functions) in <strong>Set</strong>. Morphisms are mappings <span class="math inline">\(\sigma_{\mathcal{Q}} : (\varphi_1, Z_1) \to (\varphi_2, Z_2)\)</span> such that one exists if and only if <span class="math inline">\(\exists \sigma \in (Z_1 \to Z_2), \sigma \varphi_1 = \varphi_2\)</span>, and <span class="math inline">\(\forall a&#39;, a&#39;&#39; \in A, a&#39; \sim a&#39;&#39; \Rightarrow \varphi(a&#39;) = \varphi(a&#39;&#39;)\)</span>.</p>
<p>Since the textbook also asks whether such a category has initial objects, we will first also answer this and consider all terminal objects.</p>
<p>The initial object of a general coslice category is <span class="math inline">\(id_A\)</span>. This is easily verified by doing <span class="math inline">\(\varphi_1 = id_A\)</span>, necessarily <span class="math inline">\(\sigma \varphi_1 = \sigma id_A = \sigma = \varphi_2\)</span>, and so <span class="math inline">\(\sigma\)</span> always exists and is unique. We also see that this object satisfies the "equivalence preservation" condition, hence it exists in <span class="math inline">\(\mathcal{Q}\)</span>, and is also the initial object in <span class="math inline">\(\mathcal{Q}\)</span>.</p>
<p>A general coslice category has a final object <span class="math inline">\((t, F)\)</span> (or many final objects <span class="math inline">\((t_i, F_i)\)</span>) iff <span class="math inline">\(\mathcal{C}\)</span> has a final object <span class="math inline">\(F\)</span> (or many final objects <span class="math inline">\(F_i\)</span>). In that case, any final object <span class="math inline">\((t, F)\)</span> in <span class="math inline">\(\mathcal{C}_A\)</span> corresponds to the unique morphism from <span class="math inline">\(A\)</span> to <span class="math inline">\(F\)</span> (for any final <span class="math inline">\(F\)</span>) in <span class="math inline">\(\mathcal{C}\)</span>. Let us verify this.</p>
<p>Let <span class="math inline">\(F\)</span> be final in <span class="math inline">\(\mathcal{C}\)</span>, and <span class="math inline">\(t\)</span> be the unique morphism <span class="math inline">\(t \in Hom_{\mathcal{C}} (A, F)\)</span>. Let <span class="math inline">\((\varphi, Z)\)</span> be an arbitrary object of <span class="math inline">\(\mathcal{C}_A\)</span>. Let be <span class="math inline">\(\sigma\)</span> such that <span class="math inline">\(\sigma \varphi = t\)</span>. We consider the following diagram:</p>
<p>Since <span class="math inline">\(F\)</span> is final in <span class="math inline">\(\mathcal{C}\)</span>, <span class="math inline">\(\sigma\)</span> is unique and always exists. Also, since <span class="math inline">\(\sigma\)</span> is unique and always exist, the choice of <span class="math inline">\(\varphi\)</span> is irrelevant: this same <span class="math inline">\(\sigma\)</span> works for all choices of <span class="math inline">\(\varphi\)</span> for a given arbitrary <span class="math inline">\(Z\)</span>. This proves that <span class="math inline">\(\sigma_{\mathcal{C}_A}\)</span> exists and is unique for all <span class="math inline">\((\varphi, Z)\)</span>. Finally, since <span class="math inline">\(\sigma\)</span> works for all choices of <span class="math inline">\(\varphi\)</span>, it works for those that satisfy the "equivalence preservation" condition, and so does <span class="math inline">\(t\)</span>: this means that <span class="math inline">\((t, F)\)</span> is indeed a final object in <span class="math inline">\(\mathcal{Q}\)</span>.</p>
<h4 class="unnumbered" id="section-43">5.6)</h4>
<p>Consider the category corresponding to endowing (as in Example 3.3) the set <span class="math inline">\(\mathbb{Z}^+\)</span> of positive integers with the divisibility relation. Thus there is exactly one morphism <span class="math inline">\(d \to m\)</span> in this category if and only if <span class="math inline">\(d\)</span> divides <span class="math inline">\(m\)</span> without remainder; there is no morphism between <span class="math inline">\(d\)</span> and <span class="math inline">\(m\)</span> otherwise. Show that this category has products and coproducts. What are their ’conventional’ names? [§VII.5.1]</p>
<p>Like example 3.3, this is a case of "category made from an order relation over a set", since divisibility is an order relation (reflexive, antisymmetric, transitive).</p>
<p>Let us remind the definition of categorical products and coproducts. We consider some general category <span class="math inline">\(\mathcal{C}\)</span>.</p>
<p>An object <span class="math inline">\(A \prod B\)</span> is the product of two objects <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> iff there is a unique morphism <span class="math inline">\(\pi_A\)</span> (resp. <span class="math inline">\(\pi_B\)</span>) from <span class="math inline">\(A \prod B\)</span> to <span class="math inline">\(A\)</span> (resp. <span class="math inline">\(B\)</span>), and for every <span class="math inline">\(Z\)</span> in <span class="math inline">\(\mathcal{C}\)</span>, and for every pair of morphisms <span class="math inline">\(f_A : Z \to A\)</span> and <span class="math inline">\(f_B : Z \to B\)</span>, there exists a single morphism <span class="math inline">\(\sigma = f_A \prod f_B\)</span> such that <span class="math inline">\(\pi_A \sigma = f_A\)</span> and <span class="math inline">\(\pi_B \sigma = f_B\)</span>. This is summarized in the following commutative diagram.</p>
<p>An object <span class="math inline">\(A \coprod B\)</span> is the coproduct of two objects <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> iff there is a unique morphism <span class="math inline">\(i_A\)</span> (resp. <span class="math inline">\(i_B\)</span>) from <span class="math inline">\(A\)</span> (resp. <span class="math inline">\(B\)</span>) into <span class="math inline">\(A \coprod B\)</span>, and for every <span class="math inline">\(Z\)</span> in <span class="math inline">\(\mathcal{C}\)</span>, and for every pair of morphisms <span class="math inline">\(f_A : A \to Z\)</span> and <span class="math inline">\(f_B : B \to Z\)</span>, there exists a single <span class="math inline">\(\sigma = f_A \coprod f_B)\)</span> such that <span class="math inline">\(\sigma i_A = f_A\)</span> and <span class="math inline">\(\sigma i_B = f_B\)</span>. This is summarized in the following commutative diagram.</p>
<p>We now return to our "divisibility order category". We write its objects as simple integers, and the (if it exists, unique) morphism representing "divisibility of <span class="math inline">\(m\)</span> by <span class="math inline">\(n\)</span>" as <span class="math inline">\((n | m)\)</span>. The conventional name of the product for this category is "greatest common divisor" (or "meet"), and of the coproduct, "least common multiple" (or "join").</p>
<p>The following commutative diagrams represent this fact. Take two arbitrary naturals <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span>. Any number <span class="math inline">\(k\)</span> which divides both <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> also divides their GCD. Likewise, if <span class="math inline">\(k\)</span> is a multiple of both <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span>, then it is a multiple of their LCM.</p>
<h4 class="unnumbered" id="section-44">5.7)</h4>
<p>Redo Exercise 2.9 ("Show that if <span class="math inline">\(A \simeq A&#39;\)</span> and <span class="math inline">\(B \simeq B&#39;\)</span> , and further <span class="math inline">\(A \cap B = \emptyset\)</span> and <span class="math inline">\(A&#39; \cap B&#39; = \emptyset\)</span>, then <span class="math inline">\(A \cup B \simeq A&#39; \cup B&#39;\)</span>. Conclude that the operation <span class="math inline">\(A \coprod B\)</span> (as described in §1.4) is well-defined up to isomorphism") this time using Proposition 5.4. (the unicity up-to-isomorphism of terminal objects).</p>
<p>We define <span class="math inline">\(\text{\textbf{Set}}^{A,B}\)</span> as the "bicoslice category of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> over <strong>Set</strong>". Objects in this category are pairs of morphisms <span class="math inline">\((f,g)\)</span> from <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, respectively, into sets <span class="math inline">\(Z\)</span>. They can be diagrammed as follows.</p>
<p>Morphisms are defined between objects as</p>
<p>such that the following diagram commutes</p>
<p>Let us call <span class="math inline">\(I\)</span> the following object of <span class="math inline">\(\text{\textbf{Set}}^{A,B}\)</span>, where <span class="math inline">\(A \coprod B\)</span> is any choice of valid disjoint union of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>:</p>
<p>By definition of a coproduct, we know that in such a configuration, a morphism <span class="math inline">\(\sigma^{A,B}\)</span> from this object into any other object of <span class="math inline">\(\text{\textbf{Set}}^{A,B}\)</span> exists and is unique, and so is the <span class="math inline">\(\sigma\)</span> on which it is based. This means that <span class="math inline">\(I\)</span> is initial in <span class="math inline">\(\text{\textbf{Set}}^{A,B}\)</span>. Consequently, using prop 5.4., the fact that if an initial object exists, it is unique up-to-isomorphism, we conclude that <span class="math inline">\(A \coprod B\)</span> is unique up-to-isomorphism.</p>
<h4 class="unnumbered" id="section-45">5.8)</h4>
<h1 id="extra-exercises-byfor-the-group">Extra exercises by/for the group</h1>
<h3 class="unnumbered" id="chapter-i-1-set-notation">Chapter I) 1) Set notation)</h3>
<p>Write the following in set notation (as a list of numbers, and algebraically):</p>
<ul>
<li><p>the set of all odd integers</p></li>
<li><p>the set of all integers that are not multiples of 3</p></li>
<li><p>the set of integers from 10 (included) to 20 (included)</p></li>
<li><p>the set of integers from 10 (included) to 20 (excluded)</p></li>
<li><p>the set of pairs of integers with both elements of the same value</p></li>
<li><p>the set of triplets of real numbers that together sum to 1</p></li>
<li><p>the set of pairs of positive real numbers that together sum to 1</p></li>
<li><p>the set of <span class="math inline">\(n\)</span>-tuplets (for any <span class="math inline">\(n\)</span>) of real number that together sum to 1</p></li>
<li><p>the set of all natural numbers such that there exists at least one triplet of positive even numbers which are all different and which sum to that number.</p></li>
</ul>
<p>Now take the sets in their algebraic notation, and represent them both as a list of numbers (as a logical sequence or just a couple of examples), and as a "description" of what they are:</p>
<ul>
<li><p><span class="math inline">\(\{3n + 2 \; | \; n \in \mathbb{N} \}\)</span></p></li>
<li><p><span class="math inline">\(\{3k + 2 \; | \; k \in \mathbb{Z} \}\)</span></p></li>
<li><p><span class="math inline">\(\{ 2^i \; | \; i \in [[0, 10]] \}\)</span></p></li>
<li><p><span class="math inline">\(\{ (x, y) \in \mathbb{R}^2 \; | \; x^2 + y^2 = 1 \}\)</span></p></li>
<li><p><span class="math inline">\(\{ x \in \mathbb{R} \; | \; -2 \leq x \leq 2 \}\)</span></p></li>
<li><p><span class="math inline">\(\{ (m, n, p) \in \mathbb{N}^3 \; | \; m + n + p = 10 \}\)</span></p></li>
</ul>
<h1 id="notes">Notes</h1>
<h2 class="unnumbered" id="chapter-1-section-1">Chapter 1, Section 1</h2>
<p>Go check out the extra exercises on set notation.</p>
<h2 class="unnumbered" id="chapter-1-section-2">Chapter 1, Section 2</h2>
<h3 class="unnumbered" id="on-injections-and-surjections">On injections and surjections</h3>
<h4 class="unnumbered" id="injections">Injections</h4>
<p>Injections (which aren’t also surjections) have multiple left-inverses (post-inverses). Eg:</p>
<p><span class="math display">\[A = \{ a, b    \}\]</span> <span class="math display">\[B = \{ 1, 2, 3 \}\]</span> <span class="math display">\[f : A \to B = \{ (a, 2), (b, 3) \} \text{, injective}\]</span></p>
<p><span class="math display">\[g_1 : B \to A = \{ (1, a), (2, a), (3, b) \}\]</span> <span class="math display">\[g_2 : B \to A = \{ (1, b), (2, a), (3, b) \}\]</span></p>
<p><span class="math display">\[g_1 \circ f = g_2 \circ f = id_A\]</span></p>
<p>It is precisely the free element with no antecedent in <span class="math inline">\(B\)</span> (here, <span class="math inline">\(1\)</span>) which leaves room for multiple choices, but doesn’t affect the overall inversion process.</p>
<h4 class="unnumbered" id="surjections">Surjections</h4>
<p>Surjections (which aren’t also injections) have multiple right-inverses (pre-inverses), called sections.</p>
<p><span class="math display">\[B = \{ 1, 2, 3 \}\]</span> <span class="math display">\[A = \{ a, b    \}\]</span> <span class="math display">\[f : B \to A = \{ (1, a), (2, a), (3, b) \} \text{, surjective}\]</span></p>
<p><span class="math display">\[g_1 : A \to B = \{(a, 1), (b, 3) \}\]</span> <span class="math display">\[g_2 : A \to B = \{(a, 2), (b, 3) \}\]</span></p>
<p><span class="math display">\[f \circ g_1 = f \circ g_2 = id_A\]</span></p>
<p>It is precisely the fact that there are multiple elements that map to the same element (here, <span class="math inline">\(1\)</span> and <span class="math inline">\(2\)</span> to <span class="math inline">\(a\)</span>) which leaves room for multiple choices, but doesn’t affect the overall inversion process.</p>
<h4 class="unnumbered" id="cancellations">Cancellations</h4>
<p>Function Cancellation Lemma: If a composition of functions cancels out, then the first of the pair is an injection, and the second of the pair is a surjection. Algebraically: <span class="math display">\[\forall A, B \in Obj(\textbf{Set}),
f \in (A \to B), g \in (B \to A), \;
    g \circ f = id_A
\Rightarrow
    \begin{cases}
        f \text{ is injective} \\
        g \text{ is surjective}
    \end{cases}\]</span></p>
<p>Corollary 1: any post-inverse of an injection is a surjection.</p>
<p>Corollary 2: any pre-inverse of a surjection is an injection.</p>
<p>Proof: Let be <span class="math display">\[A, B \in Obj(\textbf{Set}), f \in (A \to B), g \in (B \to A), \; g \circ f = id_A\]</span></p>
<p>a) Suppose <span class="math inline">\(f\)</span> is not an injection. This means: <span class="math display">\[\exists x, y \in B, \; x \neq y \text{ and } g(x) = g(y)\]</span> However, with such an <span class="math inline">\(f\)</span>, we have: <span class="math display">\[g(x) = g(y) \Rightarrow f(g(x)) = f(g(y)) = id_A(x) = id_A(y) = x = y\]</span> This means that <span class="math inline">\(f\)</span> is an injection. Contradiction.</p>
<p>Conclusion: in this context, <span class="math inline">\(f\)</span> must be an injection.</p>
<p>b) Suppose <span class="math inline">\(g\)</span> is not a surjection. This means: <span class="math display">\[\exists a \in A, \; a \notin g(B)\]</span> Since <span class="math inline">\(g \circ f = id_A\)</span>, that means that <span class="math inline">\(g(f(a)) = id_A(a) = a\)</span>, this means that <span class="math inline">\(a \in g(B)\)</span>. Contradiction.</p>
<p>Conclusion: in this context, <span class="math inline">\(g\)</span> must be a surjection.</p>
<h3 class="unnumbered" id="on-sections-and-fibers">On sections and fibers</h3>
<p>Section example with a tangent bundle.</p>
<p>Consider the cylinder <span class="math inline">\(S^1 \times \mathbb{R}\)</span>, and the function <span class="math inline">\(f : S^1 \times \mathbb{R} \to S^1\)</span>, the projection onto the circle. The cylinder is itself the space in which one can easily represent maps of <span class="math inline">\((S^1 \to \mathbb{R})\)</span>. Each such map corresponds to a section.</p>
<p>Let be</p>
<p><span class="math display">\[\begin{aligned}
g_1 : S^1    &amp; \longrightarrow  S^1 \times \mathbb{R} \\
      \theta &amp; \longmapsto      (\theta, 1)
\end{aligned}\]</span></p>
<p><span class="math display">\[\begin{aligned}
g_2 : S^1    &amp; \longrightarrow  S^1 \times \mathbb{R} \\
      \theta &amp; \longmapsto      (\theta, cos(\theta))
\end{aligned}\]</span></p>
<p>We have <span class="math display">\[f \circ g_1 = f \circ g_2 = id_{S^1}\]</span></p>
<p>(TODO add diagrams for S1xR, g1 and g2)</p>
<p>A fiber is the preimage of a singleton. In the case of <span class="math inline">\(f\)</span> above, for every <span class="math inline">\(q \in S^1\)</span>, <span class="math inline">\(f^{-1}({q})\)</span> is the copy of the real line on the cylinder that passes by <span class="math inline">\(q\)</span>.</p>
<p>(TODO add diagram)</p>
<h3 class="unnumbered" id="alternative-characterization-of-a-bijection">Alternative characterization of a bijection</h3>
<p>"<span class="math inline">\(f\)</span> is bijective" <span class="math inline">\(\Leftrightarrow\)</span> ("every element of <span class="math inline">\(B\)</span> has a non-empty fiber" (surjection) and "every fiber is a singleton" (injection))</p>
<h3 class="unnumbered" id="on-monomorphisms-and-epimorphisms">On monomorphisms and epimorphisms</h3>
<h4 class="unnumbered" id="failing-the-monoepi-condition">Failing the mono/epi condition</h4>
<h5 class="unnumbered" id="example-of-failing-the-monomorphism-definition-for-a-non-injection">Example of failing the monomorphism definition for a non-injection</h5>
<p>Monomorphism definition:</p>
<p><span class="math display">\[\text{$f : A \to B$ is a monomorphism}
\\ \Leftrightarrow \\
\forall Z \in \text{Obj}(\mathcal{C}), \;
\forall g_1, g_2 \in \text{Hom}(Z, A), \;
(f \circ g_1 = f \circ g_2 \Rightarrow g_1 = g_2)\]</span></p>
<p><span class="math display">\[A = \{ a, b, c \}\]</span> <span class="math display">\[B = \{ 1, 2    \}\]</span> <span class="math display">\[Z = \{ x, y    \}\]</span> <span class="math display">\[f : A \to B = \{ (a, 1), (b, 1), (c, 2) \} \text{, not injective}\]</span></p>
<p><span class="math display">\[g_1 : Z \to A = \{ (x, a), (y, c) \}\]</span> <span class="math display">\[g_2 : Z \to A = \{ (x, b), (y, c) \}\]</span></p>
<p><span class="math display">\[f \circ g_1 = f \circ g_2 = \{(x, 1), (y, 2)\} \in (Z \to B)\]</span></p>
<p>The multiple choice of elements (here, <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>) in <span class="math inline">\(A\)</span> which map to <span class="math inline">\(1\)</span> in <span class="math inline">\(B\)</span> is precisely what allows the overall composition to be equal, even when <span class="math inline">\(g_1 \neq g_2\)</span>. This provides insight into a proof of "<span class="math inline">\(f\)</span> is a monomorphism implies that <span class="math inline">\(f\)</span> is an injection". If you suppose that <span class="math inline">\(f\)</span> is a monomorphism and not an injection, you can easily reach a contradiction, since you can use elements like <span class="math inline">\(1\)</span> and <span class="math inline">\(2\)</span> that both map to the same <span class="math inline">\(a\)</span> to construct a counter-example to the implication that defines a monomorphism.</p>
<h5 class="unnumbered" id="example-of-failing-the-epimorphism-definition-for-a-non-surjection">Example of failing the epimorphism definition for a non-surjection</h5>
<p>Epimorphism definition:</p>
<p><span class="math display">\[\text{$f : A \to B$ is an epimorphism}
\\ \Leftrightarrow \\ 
\forall Z \in \text{Obj}(\mathcal{C}), \;
\forall g_1, g_2 \in \text{Hom}(B, Z), \;
(g_1 \circ f = g_2 \circ f \Rightarrow g_1 = g_2)\]</span></p>
<p><span class="math display">\[g_1 : Z \to A = \{ (x, a), (y, c) \}\]</span> <span class="math display">\[g_2 : Z \to A = \{ (x, b), (y, c) \}\]</span></p>
<p><span class="math display">\[f \circ g_1 = f \circ g_2 = \{(x, 1), (y, 2)\} \in (Z \to B)\]</span></p>
<p><span class="math display">\[A = \{ a, b    \}\]</span> <span class="math display">\[B = \{ 1, 2, 3 \}\]</span> <span class="math display">\[Z = \{ x, y    \}\]</span> <span class="math display">\[f : A \to B = \{ (a, 1), (b, 2) \} \text{, not surjective}\]</span></p>
<p><span class="math display">\[g_1 : B \to Z = \{ (1, x), (2, y), (3, x) \}\]</span> <span class="math display">\[g_2 : B \to Z = \{ (1, x), (2, y), (3, y) \}\]</span></p>
<p><span class="math display">\[g_1 \circ f = g_2 \circ f = \{(a, x), (b, y)\} \in (A \to Z)\]</span></p>
<p>The element <span class="math inline">\(3\)</span> in <span class="math inline">\(B\)</span> not being reached by <span class="math inline">\(f\)</span> is precisely that which provides the opportunity to build <span class="math inline">\(g_1 \neq g_2\)</span> such that they compose to the same result with <span class="math inline">\(f\)</span>, since the output of <span class="math inline">\(3\)</span> for them doesn’t affect the overall composition. This provides insight into a proof of "<span class="math inline">\(f\)</span> is an epimorphism implies that <span class="math inline">\(f\)</span> is a surjection". If you suppose that <span class="math inline">\(f\)</span> is an epimorphism and not a surjection, you can easily reach a contradiction, since you can use elements like <span class="math inline">\(3\)</span> that are not reached by <span class="math inline">\(f\)</span> to construct a counter-example to the implication that defines an epimorphism.</p>
<h4 class="unnumbered" id="proofs-of-monoinj-and-episurj-equivalence">Proofs of mono/inj and epi/surj equivalence</h4>
<p>Let <span class="math inline">\(f : A \to B\)</span>.</p>
<p>The parts which are "Injection =&gt; Monomorphism" and "Surjection =&gt; Epimorphism" both use the respective sided inverses to prove the implication.</p>
<p>The other parts use the following tautology to prove the implication by contradiction. "Suppose that <span class="math inline">\(p\)</span> and <span class="math inline">\(\neg q\)</span>, show that it leads to a contradiction".</p>
<p><span class="math display">\[(p \Rightarrow q)
\Leftrightarrow ((\neg  p) \cup      q )
\Leftrightarrow ( \neg (p  \cap \neg q))\]</span></p>
<h5 class="unnumbered" id="injection-monomorphism">Injection =&gt; Monomorphism</h5>
<p>Suppose that <span class="math inline">\(f\)</span> is an injection. It thus has post-inverses.</p>
<p><span class="math display">\[\exists g \in (B \to A), g \circ f = id_A\]</span></p>
<p>From there:</p>
<p><span class="math display">\[\forall Z \in \text{Obj}(\mathcal{C}), \;
\forall a, b \in \text{Hom}(Z, A),\]</span> <span class="math display">\[\begin{array}{ccccc} \\
f \circ a = f \circ b &amp; \Rightarrow &amp;  g \circ (f  \circ a) &amp;=&amp;  g \circ (f  \circ b) \\
                      &amp; =           &amp; (g \circ  f) \circ a  &amp;=&amp; (g \circ  f) \circ b  \\
                      &amp; =           &amp;         id_A \circ a  &amp;=&amp;         id_A \circ b  \\
                      &amp; =           &amp;                    a  &amp;=&amp;                    b
\end{array}\]</span></p>
<p>We conclude that <span class="math inline">\(f\)</span> is also a monomorphism.</p>
<h5 class="unnumbered" id="surjection-epimorphism">Surjection =&gt; Epimorphism</h5>
<p>Suppose that <span class="math inline">\(f\)</span> is a surjection. It thus has pre-inverses.</p>
<p><span class="math display">\[\exists g \in (B \to A), f \circ g = id_B\]</span></p>
<p>From there:</p>
<p><span class="math display">\[\forall Z \in \text{Obj}(\mathcal{C}), \;
\forall a, b \in \text{Hom}(B, Z),\]</span> <span class="math display">\[\begin{array}{ccccc} \\
a \circ f = b \circ f &amp; \Rightarrow &amp; (a \circ  f) \circ g  &amp;=&amp; (b \circ  f) \circ g  \\
                      &amp; =           &amp;  a \circ (f  \circ g) &amp;=&amp;  b \circ (f  \circ g) \\
                      &amp; =           &amp;  a \circ  id_B        &amp;=&amp;  b \circ  id_B        \\
                      &amp; =           &amp;  a                    &amp;=&amp;  b
\end{array}\]</span></p>
<p>We conclude that <span class="math inline">\(f\)</span> is also an epimorphism.</p>
<h5 class="unnumbered" id="monomorphism-injection">Monomorphism =&gt; Injection</h5>
<p>Suppose that <span class="math inline">\(f\)</span> is a monomorphism.</p>
<p><span class="math display">\[\forall Z \in \text{Obj}(\mathcal{C}), \;
\forall g_1, g_2 \in \text{Hom}(Z, A), \;
f \circ g_1 = f \circ g_2 \Rightarrow g_1 = g_2\]</span></p>
<p>Suppose now that <span class="math inline">\(f\)</span> is not an injection. Algebraically, this means that:</p>
<p><span class="math display">\[\exists (x, y) \in A^2, \text{ such that } x \neq y \text{ and } f(x) = f(y)\]</span></p>
<p>We can construct <span class="math inline">\(g_1\)</span> and <span class="math inline">\(g_2\)</span> such that <span class="math inline">\(f \circ g_1 = f \circ g_2\)</span> but <span class="math inline">\(g_1 \neq g_2\)</span>, using such a pair <span class="math inline">\((x, y)\)</span>. Thereby, we prove that <span class="math inline">\(f\)</span> is not an monomorphism and arrive at a contradiction.</p>
<p>(If <span class="math inline">\(Z\)</span> is the empty set, being initial in <span class="math inline">\(\mathbf{Set}\)</span>, there is only 1 map into <span class="math inline">\(A\)</span> (the empty map) and <span class="math inline">\(a = b\)</span> always hold. Therefore, any counterexample to the epimorphism definition needs to have at least 1 element.)</p>
<p>Let <span class="math inline">\(Z = \{a\}\)</span>.</p>
<p><span class="math display">\[g_1(a) = x\]</span> <span class="math display">\[g_2(a) = y\]</span></p>
<p>Clearly, <span class="math inline">\(g_1 \neq g_2\)</span>. However, we also have:</p>
<p><span class="math display">\[f(g_1(a)) = f(x) = f(y) = f(g_2(a)) \Rightarrow
f \circ g_1 = f \circ g_2\]</span></p>
<p>This means that <span class="math inline">\(f\)</span> is not a monomorphism: contradiction.</p>
<p>Conclusion: <span class="math inline">\(f\)</span> is an injection.</p>
<h5 class="unnumbered" id="epimorphism-surjection">Epimorphism =&gt; Surjection</h5>
<p>Suppose that <span class="math inline">\(f\)</span> is an epimorphism.</p>
<p><span class="math display">\[\forall Z \in \text{Obj}(\mathcal{C}), \;
\forall g_1, g_2 \in \text{Hom}(B, Z), \;
g_1 \circ f = g_2 \circ f \Rightarrow g_1 = g_2\]</span></p>
<p>Suppose now that <span class="math inline">\(f\)</span> isn’t a surjection. Algebraically, this means that:</p>
<p><span class="math display">\[\exists x \in B, x \notin f(A)\]</span></p>
<p>We can construct <span class="math inline">\(g_1\)</span> and <span class="math inline">\(g_2\)</span> such that <span class="math inline">\(g_1 \circ f = g_2 \circ f\)</span> but <span class="math inline">\(g_1 \neq g_2\)</span>, using such an <span class="math inline">\(x \notin f(A)\)</span>. Thereby, we prove that <span class="math inline">\(f\)</span> is not an epimorphism and arrive at a contradiction.</p>
<p>(If <span class="math inline">\(Z\)</span> is the singleton set, being terminal in <span class="math inline">\(\mathbf{Set}\)</span>, there is only 1 map into <span class="math inline">\(Z\)</span> and <span class="math inline">\(a = b\)</span> always hold. Therefore, any counterexample to the epimorphism definition needs to have at least 2 elements. We will however use a 3-element set, since it makes things more intuitive and pedagogical.)</p>
<p>Let <span class="math inline">\(Z = \{a, b, c\}\)</span>.</p>
<p><span class="math display">\[g_1 =
\begin{cases}
    \forall x    \in f(A), g_1(x) = a \\
    \forall x \notin f(A), g_1(x) = b
\end{cases}\]</span></p>
<p><span class="math display">\[g_2 =
\begin{cases}
    \forall x    \in f(A), g_2(x) = a \\
    \forall x \notin f(A), g_2(x) = c
\end{cases}\]</span></p>
<p>Clearly, <span class="math inline">\(g_1 \neq g_2\)</span>. However, since <span class="math inline">\(A\)</span> is the domain of <span class="math inline">\(f\)</span>, of <span class="math inline">\(g_1 \circ f\)</span>, and of <span class="math inline">\(g_2 \circ f\)</span>, we have:</p>
<p><span class="math display">\[g_1 \circ f = g_2 \circ f = (x \mapsto a) \in (A \to Z)\]</span></p>
<p>This means that <span class="math inline">\(f\)</span> is not an epimorphism: contradiction.</p>
<p>Conclusion: <span class="math inline">\(f\)</span> is a surjection.</p>
<h2 class="unnumbered" id="chapter-1-section-3">Chapter 1, Section 3</h2>
<h3 class="unnumbered" id="example-summary">Example summary</h3>
<ul>
<li><p>(3.2): Set, category of sets as objects and set functions as morphisms.</p></li>
<li><p>(3.3): preorder (or order, or equivalence relation) over a (single) set, transformed into a category; elements of the set as objects, and elements of the preorder (which is a relation, hence a subset of the cartesian product) as morphisms.</p></li>
<li><p>(3.4): the powerset with the inclusion operator, transformed into a category; elements of the powerset (i.e., subsets of the set) as objects, and inclusion relations as morphisms (this is just an example of a preorder / order / equivalence category seen in 3.3).</p></li>
<li><p>(3.5): slice categories <span class="math inline">\(\mathcal{C}_A\)</span>, categories which isolate a specific object <span class="math inline">\(A\)</span> of a given category <span class="math inline">\(\mathcal{C}\)</span>, and studies the morphisms into that object; an object of <span class="math inline">\(\mathcal{C}_A\)</span> is any morphism from any arbitrary objet <span class="math inline">\(Z\)</span> into <span class="math inline">\(A\)</span> (not the homset <span class="math inline">\(Hom(Z, A)\)</span> itself !) and a morphism in <span class="math inline">\(\mathcal{C}_A\)</span> (from <span class="math inline">\(z_1 \in Z_1 \to A\)</span> to <span class="math inline">\(z_2 \in Z_2 \to A\)</span>) is a "raising" <span class="math inline">\(\sigma_A\)</span> into <span class="math inline">\(\mathcal{C}_A\)</span> of a morphism <span class="math inline">\(\sigma \in Z_1 \to Z_2\)</span> in <span class="math inline">\(\mathcal{C}\)</span> that preserves composition on morphisms in <span class="math inline">\(\mathcal{C}\)</span> (i.e., <span class="math inline">\(z_1 = z_2 \sigma \Rightarrow \sigma_A z_1 = z_2\)</span>).</p></li>
<li><p>(3.6): combining examples 3.3 and 3.5, first start with an order category on the set <span class="math inline">\(\mathbb{Z}\)</span> (there is a morphism <span class="math inline">\(m \to n\)</span> iff <span class="math inline">\(m \leq n\)</span>), then select a specific object (here, <span class="math inline">\(A = 3\)</span>) then study all morphisms of the category into <span class="math inline">\(A\)</span> (so the relation <span class="math inline">\(n \leq 3\)</span> for any <span class="math inline">\(Z = n\)</span>); the morphisms <span class="math inline">\(\sigma_3 = (m, 3) \to (n, 3)\)</span> are then simply given by the transitivity of <span class="math inline">\(\leq\)</span>, i.e., <span class="math inline">\(m \leq n \leq 3\)</span> (<span class="math inline">\((m, 3) \to (n, 3)\)</span> corresponds to <span class="math inline">\(m \leq 3 \Rightarrow n \leq 3\)</span>, meaning our <span class="math inline">\(z_1 = z_2 \sigma\)</span> transforming into <span class="math inline">\(\sigma_A z_1 = z_2\)</span>, here, corresponds to <span class="math inline">\((m \leq 3) = (n \leq 3) \cap (m \leq n)\)</span> is transformed into <span class="math inline">\((m \leq 3 \Rightarrow n \leq 3) \cap (m \leq 3) \Leftrightarrow (n \leq 3)\)</span>).</p></li>
<li><p>(3.7): coslice categories (morphisms out of a chosen object).</p></li>
<li><p>(3.8): the category <strong>Set<span class="math inline">\(^\star\)</span></strong> of pointed sets, a coslice category over <strong>Set</strong> and any singleton set <span class="math inline">\(\{ \star \}\)</span>. Objects in <strong>Set<span class="math inline">\(^\star\)</span></strong> are regular sets, but with a unique distinguished element; morphisms are any set functions that map the domain’s distinguised element to the codomain’s distinguished element.</p></li>
<li><p>(3.9): "bislice" and "bicoslice" categories, basically a similar construct as slice and coslice, but taking two objects of the starting category, and studying pairs of morphisms (from a common domain, resp codomain) into (resp from) this pair.</p></li>
<li><p>(3.10): "fibered bislice" and "fibered bicoslice" categories, once again a similair construct, but this time taking two <em>morphisms</em> into a common set C (resp. from a common set C).</p></li>
</ul>
<h3 class="unnumbered" id="on-terminal-and-initial-objects-in-set">On terminal and initial objects in <strong>Set</strong></h3>
<p>If <span class="math inline">\(\empty\)</span> is initial and <span class="math inline">\(\{ \star \}\)</span> is terminal, it is because a function in <span class="math inline">\(Set\)</span> (in categorical terms) must always have an output for every input. Ie, in category theory, all functions are maps ("applications").</p>
<p>Said algebraically:</p>
<p><span class="math display">\[\forall A, B \in \text{Obj}(\bold{Set}), \;
\forall a \in A, \;
\forall f \in \text{Hom}(A, B), \;
\exists f(a) \in B\]</span></p>
<p>In the case of <span class="math inline">\(\empty\)</span> as the input set, and there is only one function <span class="math inline">\(f: \empty \to Z\)</span> for any <span class="math inline">\(Z\)</span>: <span class="math inline">\(f\)</span> is the empty mapping. But any <span class="math inline">\(Z \to \empty\)</span> (expept <span class="math inline">\(\empty \to \empty\)</span>) contains no mapping (since we’d necessarily be ignoring at least one element of <span class="math inline">\(Z\)</span>).</p>
<p>Similarly, in the case of the (unique up-to-isomorphism) singleton set <span class="math inline">\(\{ \star \}\)</span> as the output, you’d have multiple functions (precisely <span class="math inline">\(2^{|Z|}\)</span>) into it, if you could ignore some elements of the input set. However, if all elements of the input set are required, that leaves you with only one function possible from <span class="math inline">\(Z \to \{ \star \}\)</span>: the function which maps all elements to <span class="math inline">\(\star\)</span>.</p>
<h3 class="unnumbered" id="restrictions-and-extensions-of-functions-and-its-consequences-on-a-functions-nature">Restrictions and extensions of functions, and its consequences on a function’s nature</h3>
<p>8 possibilities to study, based on the following binary dichotomies:</p>
<ul>
<li><p>injection or surjection</p></li>
<li><p>enlarging or restricting</p></li>
<li><p>domain or codomain</p></li>
</ul>
<p>Note that enlarging the domain sometimes implies enlarging the codomain, and restricting the codomain sometimes implies restricting the domain.</p>
<p>Legend: Yes, No, Depends</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">enlarge dom</td>
<td style="text-align: center;">restrict dom</td>
<td style="text-align: center;">enlarge cod</td>
<td style="text-align: center;">restrict cod</td>
</tr>
<tr class="even">
<td style="text-align: center;">injection</td>
<td style="text-align: center;">D</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">Y</td>
</tr>
<tr class="odd">
<td style="text-align: center;">surjection</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">D</td>
<td style="text-align: center;">N</td>
<td style="text-align: center;">Y</td>
</tr>
</tbody>
</table>
<p>Theorems:</p>
<p>A) if <span class="math inline">\(f \in (A \to B), f \text{ injective (resp. surjective)}\)</span>, then <span class="math inline">\(\forall Z \subseteq B, \hat{f} \in ((f^{-1}(Z) \subseteq A) \to Z), \hat{f} = f|_{f^{-1}(Z)}\)</span>, the restriction of the function to the corresponding smaller codomain, is also an injection (resp. surjection).</p>
<p>B) if <span class="math inline">\(f \in (A \to B), f \text{ injective (resp. surjective)}\)</span>, then <span class="math inline">\(\forall Z \supseteq B, \hat{f} \in (A \to Z), \hat{f} = \iota \circ f\)</span> (with the <span class="math inline">\(\iota\)</span> the canonical injection of <span class="math inline">\(b \in B\)</span> into its superset <span class="math inline">\(Z\)</span>), is also an injection (resp. is never a surjection).</p>
<p>C) if <span class="math inline">\(f \in (A \to B), f \text{ injective}\)</span>, then <span class="math inline">\(\forall Z \subseteq A, \hat{f} \in (Z \to B), f = \iota_{(Z \to A)} \circ \hat{f}\)</span>, we have that <span class="math inline">\(\hat{f}\)</span> is also an injection. However, one can construct <span class="math inline">\(Z \subseteq A\)</span> such that <span class="math inline">\(f\)</span> stops being a surjection.</p>
<p>D) if <span class="math inline">\(f \in (A \to B), f \text{ surjective}\)</span>, then <span class="math inline">\(\forall Z \supseteq A, \hat{f} \in (Z \to (B \cup f(Z))), f = \iota_{(Z \to A)} \circ \hat{f}\)</span>, we have that <span class="math inline">\(\hat{f}\)</span> is also a surjection. However, one can construct <span class="math inline">\(Z \subseteq A\)</span> such that <span class="math inline">\(f\)</span> stops being a injection.</p>
<p>Proof: TODO</p>
<h3 class="unnumbered" id="on-the-morphisms-of-slice-and-coslice-categories">On the morphisms of slice and coslice categories</h3>
<p>Given a base category <span class="math inline">\(\mathcal{C}\)</span>, and some set <span class="math inline">\(A\)</span> we wish to study the homsets of the slice (resp. coslice) category <span class="math inline">\(\mathcal{C}_A\)</span> (resp. <span class="math inline">\(\mathcal{C}^A\)</span>. <strong>These homsets might be empty, or have more than one element.</strong></p>
<p>We remind that slice categories consider <em>morphisms to A</em> as their <em>objects</em> (written as <span class="math inline">\((Z, \varphi)\)</span> for any <span class="math inline">\(\varphi : Z \to A\)</span>), while coslice categories consider <em>morphisms from A</em> as their <em>objects</em> (written as <span class="math inline">\((\varphi, Z)\)</span> for any <span class="math inline">\(\varphi : A \to Z\)</span>. <em>Morphisms</em>, of the form <span class="math inline">\(\sigma_A : (Z_1, \varphi_1) \to (Z_2, \varphi_2)\)</span> (resp. <span class="math inline">\(\sigma^A : (\varphi_1, Z_1) \to (\varphi_2, Z_2)\)</span>) in a slice category <span class="math inline">\(\mathcal{C}_A\)</span> (resp. coslice category <span class="math inline">\(\mathcal{C}^A\)</span>) map such objects to one another if and only if there exists a morphism in <span class="math inline">\(\mathcal{C}\)</span> (the base category!) such that <span class="math inline">\(\varphi_1 = \varphi_2 \sigma\)</span> (resp. <span class="math inline">\(\sigma \varphi_1 = \varphi_2\)</span>).</p>
<h4 class="unnumbered" id="example-of-no-sigma-for-a-slice-category">Example of no <span class="math inline">\(\sigma\)</span> for a slice category</h4>
<p>For example, note that there exist pairs of morphisms <span class="math inline">\(f_1 \in (Z_1 \to A)\)</span> and <span class="math inline">\(f_2 \in (Z_2 \to A)\)</span> between which there is no morphism that exists in the slice category. One such example we can make is in <span class="math inline">\((Vect_\mathbb{R})_{\mathbb{R}^2}\)</span>. If we take the maps:</p>
<p><span class="math display">\[f_1 = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 0 \end{bmatrix} \in \mathcal{L}(\mathbb{R}^2)\]</span> <span class="math display">\[f_2 = \begin{bmatrix} 0 &amp; 0 \\ 0 &amp; 1 \end{bmatrix} \in \mathcal{L}(\mathbb{R}^2)\]</span></p>
<p>There exists no map <span class="math inline">\(\sigma\)</span> such that the following diagram commutes (since the output of <span class="math inline">\(f_1\)</span> will always be null in its second coordinate, and the output of <span class="math inline">\(f_2\)</span> will always be null in the first):</p>
<h4 class="unnumbered" id="example-of-no-sigma-for-a-coslice-category">Example of no <span class="math inline">\(\sigma\)</span> for a coslice category</h4>
<p>TODO add potato diagram</p>
<p>Take <span class="math inline">\(A = Z_2 = \{ a, b, c \}\)</span>, <span class="math inline">\(\varphi_2 = id_A\)</span>, and <span class="math inline">\(Z_1 = \{ 1, 2 \}\)</span>. Since <span class="math inline">\(|Z_1| = |dom(\sigma)| &lt; |cod(\sigma)| = |Z_2|\)</span>, there is no possible case in which <span class="math inline">\(\text{Im} (\sigma) = \text{Im} (id_A)\)</span> (even if <span class="math inline">\(\varphi_1\)</span> is epi).</p>
<h4 class="unnumbered" id="example-of-multiple-sigma">Example of multiple <span class="math inline">\(\sigma\)</span></h4>
<p>TODO add potato diagram</p>
<p>Another example, this time in a coslice category, with <span class="math inline">\(A = \{ a, b, c \}\)</span>, we take <span class="math inline">\(\text{\textbf{Set}}_A\)</span>. We take <span class="math inline">\(Z_1 = \{ 1, 2, 3 \}\)</span>, <span class="math inline">\(Z_2 = \{T, F\}\)</span>. For <span class="math inline">\(\varphi_1 : A \to Z_1 = \{(a, 1), (b, 1), (c, 3)\}\)</span> and <span class="math inline">\(\varphi_2 : A \to Z_2 = \{(a, T), (b, T), (c, F)\}\)</span> there exists two elements in <span class="math inline">\(Hom_{\mathcal{Set}^A} (Z_1, Z_2)\)</span>. These originate from two functions in <strong>Set</strong>: <span class="math inline">\(\sigma_\alpha = \{ (1, T), (2, T), (3, F) \}\)</span> and <span class="math inline">\(\sigma_\beta = \{ (1, T), (2, F), (3, F) \}\)</span>. The free element in <span class="math inline">\(2 \in Z_1\)</span> which is not in <span class="math inline">\(\text{Im} (\varphi_1)\)</span> offers a degree of freedom.</p>
<h4 class="unnumbered" id="explanations-on-the-conditions-for-sigma">Explanations on the conditions for <span class="math inline">\(\sigma\)</span></h4>
<p>In the first example, what causes the issue is the fact that the images of <span class="math inline">\(f_1\)</span> and <span class="math inline">\(f_2\)</span> in <span class="math inline">\(A\)</span> are distinct.</p>
<p>In the second example, what causes the issue is the fact that we’ve reduced our common domain <span class="math inline">\(A\)</span> to an insufficient intermediary object <span class="math inline">\(Z_1\)</span>.</p>
<p>The "element which isn’t mapped to offers a degree of freedom and thus breaks unicity" in the last example should remind you of the notes on surjections. Indeed, when comparing <span class="math inline">\(\sigma_\alpha\)</span> and <span class="math inline">\(\sigma_\beta\)</span>, we’re in a context which is reminiscent of the definition of an epimorphism.</p>
<p><span class="math display">\[\varphi_2 = \sigma_\alpha \varphi_1 = \sigma_\alpha \varphi_1\]</span></p>
<p>We can be assured of being able to cancel <span class="math inline">\(\varphi 1\)</span> iff <span class="math inline">\(\varphi_1\)</span> is an epimorphism, and thus <span class="math inline">\(\sigma\)</span>, if it exists, is unique. The proof for slice categories is similar, but given the reverse orders, uses monomorphisms.</p>
<p>More generally:</p>
<ul>
<li><p>a) in a slice category, there will be no <span class="math inline">\(\sigma\)</span> if <span class="math inline">\(\text{Im} (\varphi_1) \neq \text{Im} (\varphi_2)\)</span> (proof ? and in more general categories than concrete categories ? TODO: iff ?)</p></li>
<li><p>b) in a coslice category, there will be no <span class="math inline">\(\sigma\)</span> if <span class="math inline">\(\text{Pr} (\text{Im} (\varphi_1) \neq \text{Pr} (\text{Im} (\varphi_2))\)</span> (proof ? and in more general categories than concrete categories ? TODO: iff ?)</p></li>
<li><p>c) in a slice category, there is at most a single <span class="math inline">\(\sigma\)</span> iff <span class="math inline">\(\varphi_2\)</span> is mono</p></li>
<li><p>d) in a coslice category, there is at most a single <span class="math inline">\(\sigma\)</span> iff <span class="math inline">\(\varphi_1\)</span> is epi</p></li>
</ul>
<p>(see perhaps https://ncatlab.org/nlab/show/over+category and https://ncatlab.org/nlab/show/under+category )</p>
<h2 class="unnumbered" id="chapter-1-section-4">Chapter 1, Section 4</h2>
<h3 class="unnumbered" id="notes-on-counterintuitive-rules">Notes on counterintuitive rules</h3>
<ul>
<li><p>in some categories (such as <span class="math inline">\(\mathbb{Z}\)</span> with <span class="math inline">\(\leq\)</span>; or <strong>Ring</strong>), "mono and epi" does not imply "iso"</p></li>
<li><p>in every <em>abelian</em> category, we have that "iso <span class="math inline">\(\Leftrightarrow\)</span> epi and mono" (and though <strong>Set</strong> is not abelian, the property still holds)</p></li>
<li><p>while in <strong>Set</strong>, a function is an epimorphism (surjective) iff it has a pre-inverse, in <strong>Grp</strong>, some epimorphisms do not have right inverses.</p></li>
</ul>
<h2 class="unnumbered" id="chapter-1-section-5">Chapter 1, Section 5</h2>
<h3 class="unnumbered" id="initial-and-terminal-objects">Initial and terminal objects</h3>
<ul>
<li><p>there are categories without either initial or terminal objects, such as the preorder category of <span class="math inline">\(\mathbb{Z}\)</span> with <span class="math inline">\(\leq\)</span>.</p></li>
<li><p>there are categories with multiple initial or terminal objects (for example, in <strong>Set</strong>, every singleton set is a terminal object); however, these are respectively unique up to isomorphism</p></li>
<li><p>any object which is both initial and terminal is called a zero object.</p></li>
</ul>
<h3 class="unnumbered" id="universal-properties">Universal properties</h3>
<h4 class="unnumbered" id="normal-universal-properties">"Normal" universal properties</h4>
<p>Verbatim: "The most natural context in which to introduce universal properties requires a good familiarity with the language of functors, which we will only introduce at a later stage. [...] We say that a construction satisﬁes a universal property (or: ’is the solution to a universal problem’) when it may be viewed as a terminal object of a category."</p>
<p>Then: "The declaration/explanation of a universal property generally follows the pattern ’object X is universal with respect to the following property: for any Y such that..., there exists a unique morphism Y → X such that...’; this explanation hides the deﬁnition of an accessory category, and the statement that X is terminal."</p>
<p>This is a complicated way to say: there is some construct to decompose a morphism which is "universal" (always exists) and reduces the rest of the information of the morphism into something "unique" (hence terminal object of some subcategory).</p>
<h4 class="unnumbered" id="dual-universal-properties">Dual universal properties</h4>
</body>
</html>
